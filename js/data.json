{"success":true,"data":[{"id":"5796d0272d740f7c26637e9f","author_id":"542bff0c10ab5791322617c7","tab":"share","content":"<div class=\"markdown-text\"><h1>TL; DR</h1>\n<blockquote>\n<p>来了很多小伙伴</p>\n</blockquote>\n<img src=\"http://7xkeqi.com1.z0.glb.clouddn.com/nodeparty/14th/7.pic.jpg\" width=\"500\" />\n<blockquote>\n<p>Juliet 介绍活动流程</p>\n</blockquote>\n<img src=\"http://7xkeqi.com1.z0.glb.clouddn.com/nodeparty/14th/6.pic.jpg\" width=\"500\" />\n<blockquote>\n<p>Berwin 分享Koa原理和实践</p>\n</blockquote>\n<p>下载Slides:  <a href=\"http://7xkeqi.com1.z0.glb.clouddn.com/nodeparty/14th/koa_berwin_20160723.pdf\">koa_berwin_20160723</a></p>\n<img src=\"http://7xkeqi.com1.z0.glb.clouddn.com/nodeparty/14th/2.pic.jpg\" width=\"500\" />\n<blockquote>\n<p>Hain 分享人工智能和聊天机器人</p>\n</blockquote>\n<p>下载Slides: <a href=\"http://7xkeqi.com1.z0.glb.clouddn.com/nodeparty/14th/AI_Chatbot_hain_20160723.pdf\">AI_Chatbot_hain_20160723</a></p>\n<img src=\"http://7xkeqi.com1.z0.glb.clouddn.com/nodeparty/14th/4.pic.jpg\" width=\"500\" />\n<blockquote>\n<p>二楼看客</p>\n</blockquote>\n<img src=\"http://7xkeqi.com1.z0.glb.clouddn.com/nodeparty/14th/9.pic.jpg\" width=\"500\" />\n<blockquote>\n<p>撸串</p>\n</blockquote>\n<img src=\"http://7xkeqi.com1.z0.glb.clouddn.com/nodeparty/14th/8.pic.jpg\" width=\"500\" />\n<h2>号召捐助</h2>\n<p>NodeParty一直努力推广优秀的Node.js/JavaScript技术，始终秉持着拥抱变化、创新和竭尽分享的旨意。13次活动共输出了32个主题分享，并延伸了微信公众号和多个微信群，运营NodeParty有多名志愿者，野狗科技、科技寺和珠峰培训也大力支持。为了能更好的发展NodeParty并从Web应用开发和移动应用开发基础上，将主题分享范围扩大到虚拟现实技术、人工智能技术、物联网技术，需要更多支持，如果您参加过NodeParty，认同我们的工作，请伸出援助之手。</p>\n<blockquote>\n<p>微信扫一扫</p>\n</blockquote>\n<img src=\"http://7xkeqi.com1.z0.glb.clouddn.com/nodeparty/donate-rmb100.png\" width=\"300\" />\n<h2>加入 BJ NodeJS Club</h2>\n<img src=\"http://7xkeqi.com1.z0.glb.clouddn.com/nodeparty/poster-20160616/poster_M.png\" width=\"600\" /></div>","title":"北京 7.23 NodeParty 总结","last_reply_at":"2016-08-02T10:12:50.712Z","good":false,"top":true,"reply_count":1,"visit_count":1866,"create_at":"2016-07-26T02:51:19.955Z","author":{"loginname":"Samurais","avatar_url":"https://avatars.githubusercontent.com/u/3538629?v=3&s=120"}},{"id":"575e70ef4a43c1cb159ffe25","author_id":"4f19795e817ae4105c01cc1f","tab":"share","content":"<div class=\"markdown-text\"><p>JSConf China 已经五年了，这五年来我们一直秉持着给国内JS开发者带来高质量的技术会议的宗旨。\n5年来有超过1700位开发者参加过我们的活动，也有超过80位讲师给我们带来了精彩的分享。\n今年的JSConf China 又来了，今年九月我们将在南京举办宁JS。\n我们也希望今年依然能够给大家带来一个值回票价的技术大会。\n现在购票通道已经开通，早鸟5分钟内售完 :)\n<a href=\"http://www.bagevent.com/event/58905\">http://www.bagevent.com/event/58905</a></p>\n<p>感谢几位发起人，发起这个国内最大的JavaScript开发者大会。\n也感谢他们一直以来对组织活动的支持。\n<img src=\"https://cloud.githubusercontent.com/assets/914595/16001382/3ca6953a-3184-11e6-8f52-d22e37eed623.png\" alt=\"image\"></p>\n<p><img src=\"https://cloud.githubusercontent.com/assets/914595/16001470/b949f8f2-3184-11e6-80df-6867d2bc5551.png\" alt=\"image\"></p>\n<p>JavaScript everywhere!</p>\n<p>:)</p>\n</div>","title":"中国最大的JavaScript开发者大会JSConf China 2016即宁JS 售票啦！","last_reply_at":"2016-07-29T09:56:20.458Z","good":false,"top":true,"reply_count":50,"visit_count":11632,"create_at":"2016-06-13T08:38:07.230Z","author":{"loginname":"xeodou","avatar_url":"//gravatar.com/avatar/dbefd0e4d332a8d252c0251075262e8d?s=48"}},{"id":"57a19ca55621a28b35d1e6c9","author_id":"5567cd27070e73ca2c4d922f","tab":"ask","content":"<div class=\"markdown-text\"><p>node.js来实现稍微复杂的业务，比如账户余额加扣款、库存增减、订单操作等等，用到数据库事务，各位都用什么做法。</p>\n<p>另外问一下node-mysql-transaction这个包大家用的多么，还有什么类似的可以很好的做事务处理的利器吗？</p>\n</div>","title":"mysql事务怎么搞","last_reply_at":"2016-08-03T07:26:29.468Z","good":false,"top":false,"reply_count":0,"visit_count":12,"create_at":"2016-08-03T07:26:29.468Z","author":{"loginname":"xiashulin","avatar_url":"https://avatars.githubusercontent.com/u/11418033?v=3&s=120"}},{"id":"577b7751fb1d649f05fec792","author_id":"572c54718783d212174bd765","tab":"ask","content":"<div class=\"markdown-text\"><p>两个点：\n1、@的自动提示怎么实现的\n2、@别人后，后端是怎么分析出来的，怎么把这个通知通知给被@的人\n<a href=\"/user/soliury\">@soliury</a>\n@ 下作者不算打扰吧？</p>\n</div>","title":"求教，咱们论坛里的@别人，以及提示是靠什么做的？","last_reply_at":"2016-08-03T07:22:42.754Z","good":false,"top":false,"reply_count":8,"visit_count":539,"create_at":"2016-07-05T09:01:05.173Z","author":{"loginname":"hezhongfeng","avatar_url":"https://avatars.githubusercontent.com/u/12163050?v=3&s=120"}},{"id":"57a199b75621a28b35d1e6c8","author_id":"50386c12f767cc9a51ed20cb","tab":"ask","content":"<div class=\"markdown-text\"><p>有什么关于nodejs工具制作成为RPM或者EXE的工具，可以直接打包为二进制的文件。</p>\n</div>","title":"Nodejs的工具是否可以制作成RPM或者EXE包","last_reply_at":"2016-08-03T07:13:59.836Z","good":false,"top":false,"reply_count":0,"visit_count":25,"create_at":"2016-08-03T07:13:59.836Z","author":{"loginname":"ringtail","avatar_url":"https://avatars.githubusercontent.com/u/3116693?v=3&s=120"}},{"id":"50f8bbfedf9e9fcc58a015ab","author_id":"502949ddf767cc9a51384f77","content":"<div class=\"markdown-text\"><p>其实这个站点断断续续的写了很长的时间，学了不少东西，如：<strong>node.js</strong>、<strong>mongodb</strong>、<strong>bootstrap</strong>等等。\n其实说实话node.js还是不适合做web站点，其实它更适合做高并发的接口服务\n的应用，比如网游服务器等，比起PHP来，还是很多不爽，也许用PHP我能够很快的做出这样一个来吧，一周，两周，也许还不要。\n但是无论如何，它是能做WEB程序的。\n代码其实托管到github上了，但是写得很乱，就不公布地址了，如果谁想要，留言，留邮箱吧。\n程序放到了appfog上面，有兴趣的同学过去看看吧，<a href=\"http://xiaode.cz.cc\">点这里</a>。\n鉴于大家都要源码，可以从这里<a href=\"http://vagascanner.googlecode.com/files/laner20130128.zip\">下载</a>。</p>\n<hr>\n<p>最近搬到了cloudfoundry上，速度要快些，用了GridFS做图片存储，图片加载有点慢，还写了一  个简单的爬虫，爬了些数据。哈哈，算是告一段落了。<br>\n从这里访问：<a href=\"http://xiaozhi.cloudfoundry.com\">晓知</a>。</p>\n<hr>\n<p>cloudfoundry也收费了，无家可归了，在BAE申请开通一个应用，传了上去，但是很多问题，也就一直没弄了，哎！<a href=\"http://xiaozhi123.duapp.com/\">晓知</a>。</p>\n<hr>\n<p>现在BAE的node.js可以正常使用了，地址：<a href=\"http://xiaozhi123.duapp.com/\">xiaozhi</a></p>\n<hr>\n<p>guthub地址: <a href=\"https://github.com/daimin/laner\">laner</a></p>\n</div>","title":"基于Node.js的小站","last_reply_at":"2016-08-03T06:51:57.123Z","good":false,"top":false,"reply_count":49,"visit_count":8891,"create_at":"2013-01-18T03:05:34.779Z","author":{"loginname":"vagasnail","avatar_url":"//gravatar.com/avatar/f2b196e833069e9070ad0876396f65b8?size=48"}},{"id":"54509502d0c2f0fe2f53393d","author_id":"533e230b9ac9b5890d0236f7","tab":"ask","content":"<div class=\"markdown-text\"><p>有成熟的解决方案吗？</p>\n</div>","title":"使用requirejs时怎么解决文件版号和增量更新的问题","last_reply_at":"2016-08-03T06:45:40.810Z","good":false,"top":false,"reply_count":8,"visit_count":11952,"create_at":"2014-10-29T07:19:30.809Z","author":{"loginname":"hellopao","avatar_url":"https://avatars.githubusercontent.com/u/5064875?v=3&s=120"}},{"id":"579ee22fda05b9e92af325d5","author_id":"579af61c2d740f7c26637fc0","tab":"job","content":"<div class=\"markdown-text\"><p><strong><em>Directly Apply：Jobs@btcc.com</em></strong>\n<strong><em>薪资范围：15K-25K</em></strong>\n工作地点：徐家汇飞洲国际大厦 地铁一号四号线一号口出</p>\n<h3>岗位职责</h3>\n<ol>\n<li>根据业务需求,设计和实现服务层,缓存,数据库等</li>\n<li>协同前端开发人员,约定接口规格和撰写文档,开发维护 Web API 2. 配合产品经理和 UX 设计师, 完成日常的业务功能的实现</li>\n<li>通过迭代开发,研究并持续改善性能及可用性</li>\n</ol>\n<h3>任职要求</h3>\n<ol>\n<li>精通 JS ,对闭包、事件和异步有深刻的见解</li>\n<li>2年以上前端开发经验(含 1 年以上 Node 服务端经验);熟悉 TCP/IP 、 Http 、 Websocket 通讯协议;熟悉 MySQL , Redis , MongoDB 一种或多种</li>\n<li>具备技术热情,学习能力强,有良好的代码规范,能独立完成新功能模块的接口设计 和开发工作</li>\n<li>具备安全意识,能够处理常见的漏洞和攻击方式,白帽子优先</li>\n</ol>\n<h3>关于我们</h3>\n<p>BTCC 最初以“比特币中国”的名字创立于 2011 年。是中国第一个比特币交易所,也是 目前全世界运营历史最长的比特币交易所。如今,BTCC 引领着比特币生态圈的各个方面, 提供数字货币交易所,矿池,支付网关,用户钱包和区块链刻字等服务。BTCC 在一个综 合平台提供不同的产品和服务,方便全球用户能全方面地参与数字货币领域的所有环节。 总部位于中国上海的 BTCC,致力于服务全球客户群,并在安全性、减轻风险、声誉、技 术创新方面领导整个行业。BTCC 的使命是为全世界提供最可靠、最便捷的数字货币服务。 BTCC 领导层是一支多元化的团队,由具有全球顶尖互联网、电子商务和支付系统公司工 作经历的业内专业人士组成。CEO 李启元 (Bobby Lee)出生于科特迪瓦,毕业于斯坦福 大学;在 2013 年创立 BTCC 前,任沃尔玛技术副总裁。 加拿大籍首席运营官缪永权 (Samson Mow)是一名非常资深的游戏人,曾任 Ubisoft 制作总监;在 2015 年 2 月加入 BTCC 前一直管理自己亲自创办的手游开发企业。瑞典籍首席技术官王立栋 (Mikael Wang)在瑞典创立了一家广受好评的 IT 咨询机构;2013 年加入 BTCC,此前在爱立信工作时曾 开发创新性云计算解决方案。</p>\n<h3>我们提供</h3>\n<p>BTCC 提供了一个在金融科技行业接触尖端技术、解决商业挑战的独特机会。你参与并主 导项目的机会、通过比特币获取薪酬的权利、人人标配苹果笔记本电脑大家一起玩转 Slack 和 Asana。</p>\n<ul>\n<li>缴纳五险一金;</li>\n<li>双休八小时;</li>\n<li>硅谷式办公环境;</li>\n<li>法定节假日发放精美礼品;</li>\n<li>带薪年假,8 天起步封顶 18 天;</li>\n<li>年度 Family Day(今年 6 月份是上海迪斯尼乐园);</li>\n<li>季度奖金(比特币形式发放);</li>\n<li>第十三薪;</li>\n<li>优秀员工有期权;</li>\n<li>英语培训;</li>\n<li>中文培训(面向外籍员工);</li>\n<li>商业保险;</li>\n<li>每日免费的无限量地提供员工:咖啡、可乐、雪碧、苏打水、牛奶、酸奶、椰奶、王 老吉、茶、鲜果、粗粮、饼干,水果等各种休闲食品;</li>\n<li>好的语言环境,BTCC 的高管全具备双语言能力,在这样的环境下,只要 2 年你就能掌 握一口流利的英语;</li>\n<li>公司为每一位 BTCC 的员工,配置苹果笔记本电脑或苹果台式电脑,CEO 力求每一个细 节均完美,意在让员工能全身心的投入到工作,享受工作的乐趣,达到企业与员工共同 发展;</li>\n<li>我们是一支忙的很快乐的团队;我们的团队堪比联合国 分别来自:北上广深江浙闵…港澳台,美国,加拿大,瑞典,澳大利亚,法国,新加坡 以及各种海龟,后续人力资源部将继续引入各国人才一起为 BTCC 的愿景而奋斗。\n假如你是一位具备热爱和坚持的人,\n我们已经准备好:借你一场东风,一起荣耀前行。</li>\n</ul>\n</div>","title":"【上海】招聘 Senior/Junior Node.js (研究比特币和区块链技术的互联网公司--BTCC)","last_reply_at":"2016-08-03T06:29:22.148Z","good":false,"top":false,"reply_count":4,"visit_count":319,"create_at":"2016-08-01T05:46:23.612Z","author":{"loginname":"janema-btcc","avatar_url":"https://avatars.githubusercontent.com/u/19772861?v=3&s=120"}},{"id":"57a0204460adfb1f1db842ab","author_id":"54d8c6f46a95c42f404f7e66","tab":"ask","content":"<div class=\"markdown-text\"><h1>No Directive</h1>\n<p>如果你熟悉Angular的话,对指令这个概念应该不陌生。指令可以赋予DOM元素特殊的行为,看个简单的例子</p>\n<pre class=\"prettyprint language-javascript\"><code>angular.module(&#x27;app&#x27;, [])\n  .directive(&#x27;highlight&#x27;, function () {\n    return {\n      scope: {\n        highlight: &#x27;@&#x27;\n      },\n      link: function (scope, element) {\n        element.on(&#x27;mouseenter&#x27;, function () {\n          element.css(&#x27;background-color&#x27;, scope.highlight);\n        }).on(&#x27;mouseleave&#x27;, function () {\n          element.css(&#x27;background-color&#x27;, &#x27;&#x27;);\n        });\n      }\n    }\n  });\n</code></pre><p>然后我们就可以给不同的元素赋予这个高亮特性了</p>\n<pre class=\"prettyprint language-html\"><code>&lt;div highlight=&quot;green&quot;&gt;This is div.&lt;&#x2F;div&gt;\n&lt;p highlight=&quot;red&quot;&gt;This is p.&lt;&#x2F;p&gt;\n&lt;span highlight=&quot;blue&quot;&gt;This is span.&lt;&#x2F;span&gt;\n</code></pre><p>接下来我们在React当中实现同样的功能</p>\n<pre class=\"prettyprint language-javascript\"><code>class Highlight extends React.Component {\n  static props = {\n    color: &#x27;&#x27;\n  }\n\n  handleMouseEnter = (e) =&gt; {\n    e.target.style.backgroundColor = this.props.color;\n  }\n\n  handleMouseLeave = (e) =&gt; {\n    e.target.style.backgroundColor = &#x27;&#x27;;\n  }\n\n  render() {\n    return &lt;div onMouseEnter={this.handleMouseEnter} onMouseLeave={this.handleMouseLeave}&gt;{this.props.children}&lt;&#x2F;div&gt;\n  }\n}\n\nconst ComponentA = () =&gt; &lt;span&gt;Component A&lt;&#x2F;span&gt;;\nconst ComponentB = () =&gt; &lt;p&gt;Component B&lt;&#x2F;p&gt;;\n</code></pre><pre class=\"prettyprint language-html\"><code>&lt;Highlight color=&quot;red&quot;&gt;\n  &lt;ComponentA&#x2F;&gt;\n&lt;&#x2F;Highlight&gt;\n&lt;Highlight color=&quot;green&quot;&gt;\n  &lt;ComponentB&#x2F;&gt;\n&lt;&#x2F;Highlight&gt;\n</code></pre><p>为了不侵入每个组件内部,我抽象了一个Highlight组件来实现这个功能,很明显结构上还是有所冗余,外层包了div,要做到无结构侵入\n还需要在Highlight中做一些额外处理,将事件绑定到children上。除此之外,声明结构的复杂度增加,如果我在告诉你需要添加一个tooltip的功能呢?</p>\n<p>为什么我纠结于此?先说一下我对于组件和指令的理解</p>\n<h2>我眼中的组件&amp;&amp;指令</h2>\n<h3>组件</h3>\n<p>HTML是一门声明式的语言,组件就类似于div、p等结构式的标签,通过添加组件我们可以构建我们的页面基础,例如原生的HTML是不支持Dialog\n特性的,通过拓展让我们可以在页面中声明式的使用,相比命令式的使用Dialog而言,组件的可读性、复用性更强。\n为什么目前App的开发倾向于HyBird,因为原生App组件的创建还是以命令式为主,增加了开发和维护的难度,所以需要结合原生性能的优势和WEB开发声明式的特点。</p>\n<h3>指令</h3>\n<p>指令我更愿意称之为属性拓展,最典型的一个例子就是title,可以无侵入的拓展我们组件的行为,例如</p>\n<pre class=\"prettyprint language-html\"><code>&lt;div title=&quot;This is div.&quot;&gt;div&lt;&#x2F;div&gt;\n&lt;p title=&quot;This is p.&quot;&gt;p&lt;&#x2F;p&gt;\n&lt;span title=&quot;This is span.&quot;&gt;span&lt;&#x2F;span&gt;\n</code></pre><p>然而React并没有该方面的支持,所有类似的功能只能靠组件去堆叠。就像这样</p>\n<pre class=\"prettyprint language-html\"><code>&lt;Highlight color=&quot;red&quot;&gt;\n  &lt;Tooltip title=&quot;This is component A.&quot;&gt;\n    &lt;ComponentA&#x2F;&gt;\n  &lt;&#x2F;Tooltip&gt;\n&lt;&#x2F;Highlight&gt;\n&lt;Highlight color=&quot;green&quot;&gt;\n  &lt;Tooltip title=&quot;This is component B.&quot;&gt;\n    &lt;ComponentB&#x2F;&gt;\n  &lt;&#x2F;Tooltip&gt;\n&lt;&#x2F;Highlight&gt;\n</code></pre><p>WHY?</p>\n<h1>1/3 of Change Detection</h1>\n<p>当数据改变时,MVVM框架或者React这种View库会自动帮我们更新UI,这里有一个很重要的点,框架或库是怎么知道数据改变了?\n实际上数据改变有三种情况</p>\n<ul>\n<li>事件: click, submit…</li>\n<li>异步请求</li>\n<li>定时器: setTimeout/setInterval</li>\n</ul>\n<p>先看看Angular是怎么处理的</p>\n<ul>\n<li>ng-event</li>\n<li>$http</li>\n<li>$timeout/$interval</li>\n</ul>\n<p>Angular对三种情况都进行了封装,所以可以等到<code>函数</code>执行完了再触发$digest,如果我们不使用Angular的封装,Angular直接懵逼\n例如不使用$timeout</p>\n<pre class=\"prettyprint language-javascript\"><code>angular.module(&#x27;app&#x27;, [])\n  .controller(&#x27;MyCtrl&#x27;, function ($scope) {\n    $scope.name = &#x27;xxx&#x27;;\n\n    setTimeout(function () {\n      $scope.name = &#x27;yyy&#x27;;\n    }, 1000);\n  });\n</code></pre><p>我们再来看看React的处理</p>\n<ul>\n<li>onEvent</li>\n<li>no</li>\n<li>no</li>\n</ul>\n<p>除了事件以外,另外两个没有任何处理,看个例子</p>\n<pre class=\"prettyprint language-javascript\"><code>class App extends React.Component {\n  state = {\n    val: 0\n  }\n\n  handleReactEvent = () =&gt; {\n    this.setState({val: this.state.val + 1});\n    console.log(this.state.val);\n\n    this.setState({val: this.state.val + 1});\n    console.log(this.state.val);\n  }\n\n  componentDidMount() {\n    this.setState({val: this.state.val + 1});\n    console.log(this.state.val);\n\n    this.setState({val: this.state.val + 1});\n    console.log(this.state.val);\n          \n    fetch(&#x27;&#x2F;data&#x27;).then(() =&gt; {\n      this.setState({val: this.state.val + 1});\n      console.log(this.state.val);\n\n      this.setState({val: this.state.val + 1});\n      console.log(this.state.val);\n    });\n\n    this.refs.btn.addEventListener(&#x27;click&#x27;, () =&gt; {\n      this.setState({val: this.state.val + 1});\n      console.log(this.state.val);\n\n      this.setState({val: this.state.val + 1});\n      console.log(this.state.val);\n    });\n\n  }\n\n  render() {\n    return (\n      &lt;div&gt;\n        &lt;button onClick={this.handleReactEvent}&gt;React Event&lt;&#x2F;button&gt;\n        &lt;button ref=&quot;btn&quot;&gt;DOM Event&lt;&#x2F;button&gt;\n      &lt;&#x2F;div&gt;\n\n    )\n  }\n}\n</code></pre><p>先点击React Event在点击DOM Event,然后打开控制台输出如下</p>\n<pre class=\"prettyprint\"><code>0\n0\n2\n3\n3\n3\n5\n6\n</code></pre><p>仔细观察你会发现处于React生命周期和封装事件当中时,不会立马更新state,而处于其他范围,如xhr请求和定时器当中时,就会立马更新state。\n总说setState是一个异步操作,不会立马更新UI,这里要加一个限制条件,只有处于React的生命周期函数和事件函数当中才会,否则就是一个同步的操作。\n所以我说React的Change Detection只有三分之一。即使React有Virtual DOM,有diff判断,但是这样的设计初衷在哪?</p>\n<h1>No Syntactic Sugar</h1>\n<p>直接上代码</p>\n<pre class=\"prettyprint language-javascript\"><code>render() {\n  var aClassNames, bClassNames;\n  var renderComponent = null;\n\n  if (this.state.activeA) {\n    aClassNames = &#x27;classA active&#x27;;\n  } else {\n    aClassNames = &#x27;classA&#x27;;\n  }\n\n  if (this.state.activeB) {\n    aClassNames = &#x27;classB active&#x27;;\n  } else {\n    aClassNames = &#x27;classB&#x27;;\n  }\n  \n  if (this.state.condition) {\n    renderComponent = &lt;ComponentA &#x2F;&gt;\n  } else {\n    renderComponent = &lt;ComponentB &#x2F;&gt;\n  }\n\n  return (\n    &lt;div className={aClassNames}&gt;\n      &lt;p className={bClassNames}&gt;pa&lt;&#x2F;p&gt;\n      &lt;p&gt;pb&lt;&#x2F;p&gt;\n      {renderComponent}\n    &lt;&#x2F;div&gt;\n\n  )\n}\n</code></pre><pre class=\"prettyprint language-javascript\"><code>render() {\n  return (\n    &lt;div style={% raw %}{{display: this.state.data ? &#x27;block&#x27; : &#x27;none&#x27;}}{% endraw %}&gt;\n      &lt;p&gt;{this.state.data ? this.state.data.id : &#x27;&#x27;}&lt;&#x2F;p&gt;\n      &lt;p&gt;{this.state.data ? this.state.data.name : &#x27;&#x27;}&lt;&#x2F;p&gt;\n      &lt;p&gt;...&lt;&#x2F;p&gt;\n    &lt;&#x2F;div&gt;\n\n  )\n}\n</code></pre><p>特别是上述display的处理,写起来真心烦。还有糟糕的表单,某种程度上React增加很多重复的代码,内部代码偏命令式。虽然说React可以让我们纯粹的写JavaScript,不加限制。\n但是JavaScript当中的糟粕也一并留下来了,作为一个框架也好,View库也好,难道不应该简化程序员的工作吗?</p>\n<p>The End.</p>\n</div>","title":"React的几点疑问","last_reply_at":"2016-08-03T06:18:18.459Z","good":false,"top":false,"reply_count":7,"visit_count":340,"create_at":"2016-08-02T04:23:32.929Z","author":{"loginname":"yuyang041060120","avatar_url":"https://avatars.githubusercontent.com/u/6648248?v=3&s=120"}},{"id":"57a15f787a922d6f358cd16c","author_id":"5327a086d8c548083201255e","tab":"ask","content":"<div class=\"markdown-text\"><p>就算我加了<code>io.set('origins', '*');</code>也没用，<code>so</code>上搜也没找到合适的方案 - -！</p>\n</div>","title":"socket.io在v0.9.16+的跨域问题大家是怎么解决的？","last_reply_at":"2016-08-03T06:17:33.295Z","good":false,"top":false,"reply_count":2,"visit_count":91,"create_at":"2016-08-03T03:05:28.605Z","author":{"loginname":"hwoarangzk","avatar_url":"https://avatars.githubusercontent.com/u/4715246?v=3&s=120"}},{"id":"57a163db5c5423c3352d7b26","author_id":"55ad9debb4ab1d7d02bf0e15","tab":"share","content":"<div class=\"markdown-text\"><p>最近最火的话题莫过于pokemon go了，于是我也赶紧趁着这股风做了个pokemon的网站。由于游戏在国内还没上线，深感这一块还有很多的很多潜力可挖，不过由于白天需要上班，时间吃紧，所以到社区问问是否有人愿意和我一起来维护这个网站。</p>\n<p><a href=\"http://xn--www-iq6eycq74y1sg.poke-mon.cn\">网站地址www.poke-mon.cn</a></p>\n<p>我的微信号是cauu_128 欢迎来撩</p>\n</div>","title":"React+NodeJS的Pokemon GO网站","last_reply_at":"2016-08-03T06:11:17.761Z","good":false,"top":false,"reply_count":9,"visit_count":199,"create_at":"2016-08-03T03:24:11.321Z","author":{"loginname":"cauu","avatar_url":"https://avatars.githubusercontent.com/u/3899004?v=3&s=120"}},{"id":"57a1811f53d640a735989b41","author_id":"579dc04385dba6b12ac58577","tab":"share","content":"<div class=\"markdown-text\"><p>自选Windows，Linux/香港 日本 新加坡 美国\n配置A/B/C系自由选择\n以香港Linux为例：\nA系:HDD 1个内核 1.75GB RAM  100M带宽 800G流量\nB系:SSD 1个内核   2 GB RAM  500M带宽 600G流量\nC系:SSD 1个内核 3.5 GB RAM  500M带宽 500G流量\n价格100元/月,一次性购买3个月，3个月之后可以按月付款，中途不得退款，需要的加马化腾27.556.50.567</p>\n</div>","title":"出租微软AZURE","last_reply_at":"2016-08-03T05:29:03.492Z","good":false,"top":false,"reply_count":0,"visit_count":81,"create_at":"2016-08-03T05:29:03.491Z","author":{"loginname":"ljgazy1314","avatar_url":"https://avatars.githubusercontent.com/u/16984487?v=3&s=120"}},{"id":"579d748e85dba6b12ac58561","author_id":"542940f12ca9451e1bf3c24c","tab":"job","content":"<div class=\"markdown-text\"><p>4年php经验，\n2012年开始做php相关工作，做的项目挺多的，但是一直觉得自己php玩的不好！\nnodejs是我2014年年底接触的，买了朴灵的《深入浅出nodejs》，但是里面的理论太多了，硬着头皮看了一个月，没有看完，\n又买了一本《nodejs实战》，觉得还不错，但是总感觉：纸上看来终觉浅，后来2015年年后在上海火车站附近的麦当劳里面，无意看到到电子书：<a href=\"http://ourjs.com/detail/529ca5950cb6498814000005\">http://ourjs.com/detail/529ca5950cb6498814000005</a>        nodejs初学者入门，一本全面nodejs教程，然后就从最原始的http request  response,然后了解到nodejs框架是怎么会事(这也是我做php的最强烈的愿望), 其实在我做php的时候就不太想用别人的框架，老是想研究框架是怎么会事（比如我研究yii2)，但是头都大了，也没有看出什么名堂来，上面那本电子书算是让我知道了nodejs框架是怎么会事了，然后觉得很兴奋，然后就断断续续玩js, 在写jquery的时候，公司里面同事说，没见你php多牛逼，但是发现你写js挺牛逼的，当时，我心里面那个高兴啊，别提了。。。。其实我想说我写js写的溜，而不是牛逼，另从今年开始，我发现各大招聘网站招nodejs的多了起来，而且待遇还挺高的! 所以我在想着是不是把nodejs玩的更溜一点，做为一个开发者还是要有自己的拿手好语言才是，然后nodejs前后端都能搞，div+css这些我也 会且能写网页，所以想找份nodejs相关的工作，待遇差不多就行了，我自己的目前把自己的放的比较低，公司氛围好，老大好，随和，轻松！打算好好找个公司好好干干，先写这么多，想起来了再来编辑</p>\n<p>我目前在上海\n我的微信huochai2016</p>\n</div>","title":"求nodejs职位","last_reply_at":"2016-08-03T05:20:29.718Z","good":false,"top":false,"reply_count":13,"visit_count":681,"create_at":"2016-07-31T03:46:22.601Z","author":{"loginname":"huaiguoguo","avatar_url":"https://avatars.githubusercontent.com/u/1888094?v=3&s=120"}},{"id":"57a0af02632442d2436f79a7","author_id":"578c9259b78759e813a57a14","tab":"ask","content":"<div class=\"markdown-text\"><p>res.locale.article是不是渲染模板之后的 &lt;%-article%&gt;的那部分？\n<img src=\"//dn-cnode.qbox.me/FvRKPAbaIl9A0sfm-tENs1XvA2_b\" alt=\"2.png\">\n<img src=\"//dn-cnode.qbox.me/Fufl2NdApkMlN2w90nzz5GprFdaj\" alt=\"3.png\"></p>\n</div>","title":"小白学习node，求教以下几个问题","last_reply_at":"2016-08-03T05:14:11.728Z","good":false,"top":false,"reply_count":1,"visit_count":184,"create_at":"2016-08-02T14:32:34.148Z","author":{"loginname":"tan2016","avatar_url":"https://avatars.githubusercontent.com/u/20512530?v=3&s=120"}},{"id":"57a16c237a922d6f358cd173","author_id":"5784904a69d72f545483cb11","tab":"ask","content":"<div class=\"markdown-text\"><p>想做一个让用户勾选是否7天自动登录的那种，如何动态设置过期时间</p>\n</div>","title":"请问如何动态设置session的过期时间","last_reply_at":"2016-08-03T04:59:00.631Z","good":false,"top":false,"reply_count":1,"visit_count":79,"create_at":"2016-08-03T03:59:31.417Z","author":{"loginname":"18823752727","avatar_url":"https://avatars.githubusercontent.com/u/19741494?v=3&s=120"}},{"id":"57a0192fb3f2a33b1da33075","author_id":"57a0145b60adfb1f1db8429f","tab":"job","content":"<div class=\"markdown-text\"><h1><strong><a href=\"http://www.pictureworks.biz\">Pictureworks</a>招聘后台开发工程师啦</strong></h1>\n<p><strong>我们要会写API接口的小伙伴，最好是会用MongoDB数据库\n1年以上互联网后台开发经验，有第三方支付渠道项目开发经验的优先考虑\n工作地点：上海浦东川沙</strong></p>\n<p><strong>员工福利：</strong>\n配备MacBookPro\n14天带薪年假\n无限量零食+星巴克咖啡供应\n员工聚餐\n免费班车\n出国游玩机会等\n<strong>薪资：10K起，能力优秀者具体薪资面谈，每年两次调薪机会</strong></p>\n<h2>欢迎优秀的小伙伴们<strong>自荐</strong>或者<strong>推荐</strong>，投递邮箱<strong><a href=\"mailto:496756679@qq.com\">496756679@qq.com</a></strong></h2>\n<p><strong>岗位职责：</strong>\n1、负责数据分析系统的后端架构设计、开发和优化；\n2、<strong>API接口开发</strong>：对网站后台和手机App程序接口的系统设计与开发;\n3、负责系统的日常运维、更新和升级；\n4、参与软件开发项目实施，程序优化执行；\n5、为其它部门提供技术支持等；</p>\n<p><strong>任职要求：</strong>\n1、至少<strong>1年以上互联网后台开发经验</strong>，有大型管理系统开发经验者优先考虑；\n2、<strong>精通JavaScript编程</strong>，熟悉一门后端开发语言(如Node.js/PHP/.NET/JAVA, Node.js优先考虑)，或愿意对Node.js投入大量精力学习，对移动端后端接口开发熟练；\n3、参与过大型互联网项目设计、具备架构选型经验，熟悉服务器管理，系统部署；\n4、至少精通一种数据库开发、配置、维护、性能优化(如Oracle, Sqlserver, Mysql, Redis, MongoDB)，MongoDB优先；\n5、<strong>有第三方支付渠道项目开发经验者优先考虑(如支付宝，银联，微信，电商等)</strong>。</p>\n<p><strong>员工福利：</strong>\n配备MacBookPro\n14天带薪年假\n无限量零食+星巴克咖啡供应\n员工聚餐\n免费班车\n出国游玩机会等\n<strong>薪资：10K起，能力优秀者具体薪资面谈，每年两次调薪机会</strong>\n欢迎优秀的小伙伴们<strong>自荐</strong>或者<strong>推荐</strong>，投递邮箱<strong><a href=\"mailto:496756679@qq.com\">496756679@qq.com</a></strong></p>\n</div>","title":"【上海浦东】[PWSH]招Nodejs后台1枚-10K起-配备MacBookPro-14天年假","last_reply_at":"2016-08-03T04:37:57.463Z","good":false,"top":false,"reply_count":7,"visit_count":389,"create_at":"2016-08-02T03:53:19.466Z","author":{"loginname":"Kelsiz","avatar_url":"https://avatars.githubusercontent.com/u/20785421?v=3&s=120"}},{"id":"57980b28f0d4b46026ba5519","author_id":"5507e4e053ad0efa46bc502c","tab":"job","content":"<div class=\"markdown-text\"><p>加入我们，待遇从优，装备齐全，一条大裤衩，一双人字拖，一把AK47，多劳多得，只要大干一票， 在大都市买楼不再是梦想，干两票，跻身上流社会，直接与范爷、大幂幂等大牌对话不再是距离。别再犹豫了，给你一片海域，换你一生奇迹! 诚招js猿，以下是通往你人生巅峰的列车：</p>\n<p>职位要求：\n1.熟悉mac开发环境；\n2.精通nodejs，bootstrap，HTML5，熟悉nw.js；\n3.熟悉JavaScript，对流行的JavaScript框架有实际使用经验；\n4.熟悉手机端和PC端web实现的差异，有移动平台web前端开发经验，了解移动互联网产品和行业，有在Android,iOS等平台下HTML5+CSS+JavaScript（或移动JS框架）开发经验者优先考虑；\n5.良好的沟通能力和团队协作精神，对移动互联网行业有浓厚的兴趣，有较强的研究能力和学习能力。</p>\n<p>电话：010-62978515\n邮箱：zhangdp2005@163.com\n地址：北京海淀区上地三街嘉华大厦c座</p>\n</div>","title":"诚聘node开发工程师——北京","last_reply_at":"2016-08-03T04:29:43.225Z","good":false,"top":false,"reply_count":2,"visit_count":869,"create_at":"2016-07-27T01:15:20.835Z","author":{"loginname":"zhangdp2005","avatar_url":"https://avatars.githubusercontent.com/u/11517062?v=3&s=120"}},{"id":"579febd99f22cae71c65429b","author_id":"560b957d272b724e5efefd92","tab":"ask","content":"<div class=\"markdown-text\"><p>因为这个应用面对的是国内用户，所以最好是国内的部署服务提供商。</p>\n<p>大家有什么好推荐的吗？😃</p>\n</div>","title":"最近开发了一个 koa + mongo 的应用，问问大家平时都用国内哪家的部署服务？","last_reply_at":"2016-08-03T03:57:44.825Z","good":false,"top":false,"reply_count":7,"visit_count":302,"create_at":"2016-08-02T00:39:53.715Z","author":{"loginname":"xiekw2010","avatar_url":"https://avatars.githubusercontent.com/u/1814071?v=3&s=120"}},{"id":"5771eb20d3baaf401780bc41","author_id":"563f17d0b0cedafd38970462","tab":"share","content":"<div class=\"markdown-text\"><h2>前言</h2>\n<p>加密货币是一种数字资产，随着区块链等相关技术的创新和突破，很多有形或无形资产实现了去中心化。比如我们这里分享的 <a href=\"http://ebookchain.org/\">亿书</a> 就是要把数字出版物版权进行保护，实现去中心化，解决业界多年来版权保护不力的难题。</p>\n<p>无论数字资产，还是数字出版版权，都是有明确所有权的，当前实现数字资产所属的技术手段就是本篇要介绍的<code>签名</code>。而<code>多重签名</code>是对<code>签名</code>的扩展使用，给数字资产转移提供了安全保障和技术手段。本篇，从基本概念入手，详细了解<code>签名</code>和<code>多重签名</code>的作用和代码实现。</p>\n<h2>源码</h2>\n<p>主要源码地址：</p>\n<p>signatures.js <a href=\"https://github.com/Ebookcoin/ebookcoin/blob/v0.1.3/modules/signatures.js\">https://github.com/Ebookcoin/ebookcoin/blob/v0.1.3/modules/signatures.js</a></p>\n<p>multisignatures.js <a href=\"https://github.com/Ebookcoin/ebookcoin/blob/v0.1.3/modules/multisignatures.js\">https://github.com/Ebookcoin/ebookcoin/blob/v0.1.3/modules/multisignatures.js</a></p>\n<h2>解读</h2>\n<h4>签名</h4>\n<p>（1）签名的作用和特点</p>\n<p><strong>名字的解释</strong>。<code>签名</code>是什么？有人第一反应是日常生活中的用笔<code>签名</code>，那么我会说，你的直觉是对的。不过，当很多小伙伴看到网上的很多解释，却又迷惑了，事实上不同概念在不同领域的表述是有差别的，但本质相同。我坚信生活是一切创作的源泉，任何一个概念都能从生活中找到原型，这里的“签名”也是如此。</p>\n<p><strong>签名的作用</strong>。日常生活中，凡是需要确认归属的（是签名人的，不是其他的），都需要所有者进行签名。比如，我签名了一份文件，出了问题，责任我负，我签名了一个支票，就代表将由我支付。我们普通老百姓最常见的场景，就是去银行办业务，银行职员会让你反复签一大堆的单据，想必每个人都会有深刻的印象。</p>\n<p><strong>签名的特点</strong>。人的笔迹是很个性化的，越熟练的字体，个性特征越固定，因此一个人的名字，不同的人写出完全相同笔迹的概率非常小，即便是专业模仿也可以通过技术鉴别出来，这样一来，人的<code>签名</code>就具有唯一性、可验证的特点，并被法律认可。</p>\n<p><strong>签名的验证</strong>如果，你拿着一张支票去银行兑换，银行职员会对支票上的签名和印章仔细比对，确保印章大小、样式，以及付款人签名等，与银行留存的信息一致，才会给你兑付，这就是<code>签名</code>验证。</p>\n<p>（2）比特币客户端签名功能</p>\n<p>数字资产需要签名。类比人类签名，比特币也有签名功能。如果了解比特币钱包（客户端软件），就会发现它提供了一个消息签名的功能，可以用来对其他用户通过比特币网络之外的信息进行签名和验证。我个人使用的是 <a href=\"https://www.bitcoin.org/\">比特币官方网站</a> 提供的比太钱包，如图：</p>\n<p><img src=\"//dn-cnode.qbox.me/FsXV4VnyyFu45QXY0WBB-iSTRfNa\" alt=\"bither-wallet-sign.png\"></p>\n<p>这个功能干什么用的呢？有好多小伙伴不清楚，这里举个简单的例子解释一下，具体使用的时候绝不限于这些应用。</p>\n<p>Alice开了一个网店，但没有直接接入比特币网络，不能自动确认和验证支付者。客户Imfly购买了她的产品，并用比特币支付了全部货款。因为比特币地址和交易都是公开匿名的，为了防止冒充冒领实，Alice需要确认Imfly提供的那个付款地址确实是imfly本人的，否则不能发货。这时候，就需要Imfly先把支付货款的比特币地址和相关交易<code>签名信息</code>（如图），然后通过QQ或邮件传给Alice，Alice使用客户端<code>验证信息签名</code>，才能确认交易确实是Imfly的。</p>\n<p>想象一下，如果没有<code>签名</code>功能会怎么样呢？因为比特币仅是一个匿名、安全的支付手段，但却无法确认支付方或收款方是谁，信息的不确定性，将使得比特币网络之外的交易无法达成。在中心化的世界里，这个问题是通过运营平台这个第三方达成的，比如支付宝等，双方的全部信息，平台都掌握，任何一方出现欺诈，都需要通过向平台投诉来解决。用户需要对第三方平台绝对信任，并通过牺牲个人信息安全获得交易的基本保障。</p>\n<p>（3）电子签名</p>\n<p>通过上述分析，可以理解的是，<code>签名</code>的作用是确定资产所属，其特征是简单、安全、可验证。把这个概念抽象出来，应用到计算机系统里，为了确定数字资产所属，也需要进行<code>签名</code>，这就是大家经常看到的“电子签名”的概念。在网络世界里，<code>签名</code>可以对任何需要确认的数字资产进行处理，比如比特币地址、电子书版权等，并以此来宣告重要资产的所属，这让无需监管的去中心化交易成为可能。</p>\n<p>具体开发设计中，就是加密技术代替人的笔迹，不然任何签名方法都会被模仿，而且模仿的成本极低，相反，验证的成本却很高。具体的加密或验证技术，请参考前面的章节，这里我们介绍亿书是如何使用签名技术的。</p>\n<p>亿书也具备签名能力，只不过，目前没有单独提供<code>签名信息</code>的操作供用户使用，而是通过签名，添加了<code>支付密码</code>功能，对用户帐号资产追加了一层保护。</p>\n<p>（4）亿书的支付密码</p>\n<p><code>签名</code>方法在<code>modules/signatures.js</code>文件里，类图如下：</p>\n<p><img src=\"//dn-cnode.qbox.me/Fjs42b_dNJLS814GIodgr0jZsvjt\" alt=\"signatures-class.png\"></p>\n<p>我们还是从Api开始，代码如下：</p>\n<pre class=\"prettyprint\"><code>&#x2F;&#x2F; modules&#x2F;signatures.js文件\n&#x2F;&#x2F; 179行\nrouter.map(shared, {\n  &quot;get &#x2F;fee&quot;: &quot;getFee&quot;,\n  &quot;put &#x2F;&quot;: &quot;addSignature&quot;\n});\n\n&#x2F;&#x2F; 188行\nlibrary.network.app.use(&#x27;&#x2F;api&#x2F;signatures&#x27;, router);\n</code></pre><p>通过上面的代码，可以了解<code>签名</code>提供了两个简单的公共接口：</p>\n<pre class=\"prettyprint\"><code>get &#x2F;api&#x2F;signatures&#x2F;fee -&gt; shared.getFee\nput &#x2F;api&#x2F;signatures&#x2F; -&gt; shared.addSignature &#x2F;&#x2F;签名操作\n</code></pre><p>显然，最核心的方法也就是<code>shared.addSignature</code>，代码：</p>\n<pre class=\"prettyprint\"><code>&#x2F;&#x2F; 215行\nshared.addSignature = function (req, cb) {\n\t...\n\tlibrary.scheme.validate(body, {\n\t\tproperties: {\n\t\t\t...\n\t\t},\n\t\trequired: [&quot;secret&quot;, &quot;secondSecret&quot;]\n\t}, function (err) {\n\t\t...\n\n\t\tlibrary.balancesSequence.add(function (cb) {\n\t\t\tif (body.multisigAccountPublicKey &amp;&amp; body.multisigAccountPublicKey != keypair.publicKey.toString(&#x27;hex&#x27;)) {\n\t\t\t\tmodules.accounts.getAccount({publicKey: body.multisigAccountPublicKey}, function (err, account) {\n\t\t\t\t\t...\n\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tvar transaction = library.logic.transaction.create({\n\t\t\t\t\t\t\t\ttype: TransactionTypes.SIGNATURE, &#x2F;&#x2F; 297行\n\t\t\t\t\t\t\t\tsender: account,\n\t\t\t\t\t\t\t\tkeypair: keypair,\n\t\t\t\t\t\t\t\trequester: keypair,\n\t\t\t\t\t\t\t\tsecondKeypair: secondKeypair,\n\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t\treturn cb(e.toString());\n\t\t\t\t\t\t}\n            ...\t\t\t\n}\n</code></pre><p>毫无疑问，<code>支付密码</code>也是一个简单的交易（交易类型<code>TransactionTypes.SIGNATURE</code>，见297行）。基于此，我们不难想象，添加类似比特币的<code>签名</code>功能也是件非常简单的事情，我们会在亿书下一个版本里添加这项功能，具体请关注 <a href=\"https://github.com/Ebookcoin/ebookcoin\">亿书币版本库</a> 最新进展。</p>\n<h4>多重签名</h4>\n<p>上面我们提到，比特币的匿名性，使交易处于不可信之中，最终导致用户不敢交易。有了签名功能，就有了确认双方信息的有效手段，问题总算有了解决方案。聪明的小伙伴会发现，签名和验证过程除了繁琐，并没有让我们觉得比使用第三方平台更有效、更安全。有没有更好的解决方案呢？回答是：有，那就是多重签名。</p>\n<p>（1）基本概念</p>\n<p>多重签名，可以简单的理解为一个数字资产的多个签名。签名标定的是数字资产所属和权限，多重签名预示着数字资产可由多人支配和管理。在加密货币领域，如果要动用一个加密货币地址的资金，通常需要该地址的所有人使用他的私钥（由用户专属保护）进行签名。那么，多重签名，就是动用这笔资金需要多个私钥签名，通常这笔资金或数字资产会保存在一个多重签名的地址或帐号里。这就好比，我们工作中有一份文件，需要多个部门签署才能生效一样。</p>\n<p>在实际的操作过程中，一个多重签名地址可以关联n个私钥，在需要转账等操作时，只要其中的m个私钥签名就可以把资金转移了，其中m要小于等于n，也就是说m/n小于1，可以是2/3, 3/5等等，是要在建立这个多重签名地址的时候确定好的。</p>\n<p>（2）工作原理</p>\n<p>数字资产在某种情况下，需要多人支配。换句话说，在某些特定条件下，数字资产如果无法确认归属某个特定的人，那么最好让相关人共同签署它的所有权。</p>\n<p>仍然举上面的例子，在Alice发货之后，Imfly收到货之前，这笔钱应该由第三方信用比较高的中介暂时保存，这个阶段，这笔钱要么是Alice的，要么是Imfly的，最终的归属要看Imfly是否收到货。所以，这个第三方，无论如何都是应该有的，不然Imfly就要承担大部分风险（因为比特币的单向不可逆，Imfly发送之后就没有办法收回了）</p>\n<p>这样一来，这笔钱的所属关系，在交易过程中涉及到Alice、Imfly和平台第三方（虽然不属于它，但它有权裁定资金去向），那么就应该由他们三方签名，因此网上购物就是典型的多重签名的例子。其多重签名模型就是2/3，也就是说只要他们中的两个签名，资金就可以被转移。</p>\n<p>具体到这个例子，Imfly把钱打给一个关联三方私钥的多重签名地址，如果整个交易过程顺利，只要Alice和Imfly两个签名，这笔钱就会顺利到达Alice手里。如果不顺利，他们任何一人提出仲裁，平台第三方调查之后，通过签名就能把这笔钱转给Alice或退回Imfly。这非常类似淘宝和京东的模式，但是比他们更加便捷和安全，至少不用担心第三方倒闭、挪用资金或携款跑路。</p>\n<p>（3）应用场景</p>\n<p>很显然，多重签名给了加密货币腾飞的翅膀，让它单一单项支付的能力更具吸引力，让加密货币技术应用到各行各业成为可能。这里简单的罗列几个应用场景，供探索和思考：</p>\n<ul>\n<li>电子商务。比较常见的是2/3的模式。上面电子商务网站的例子，就是最典型的场景之一，目前已经有成功的案例了。延伸一下，这类应用本质就是中介，所以还可用在各类中介机构性质的服务上。</li>\n<li>财产分割。比如夫妻双方共有财产，可以使用1/2的模式，一个账户谁都可以使用，跟各自拥有帐号一样，好处是系统忠实记录了每个人的花销，闹掰的时候很容易清算。扩展到公司合伙经营，可以使用1/n模式，n个人合伙人，都可以直接支配共有资金，具体清算时，一目了然。</li>\n<li>资金监管。其实，这是多重签名的最直接作用，一笔钱需要多个人签名才能使用，任何一个人都无法直接动用资金，这在生活中太常见了，只要灵活设置多重签名的比重模式，就能解决生活中很多问题。比如，接着上面夫妻的例子，夫妻要储备一笔资金，供孩子上大学使用，在这之前谁都不能动，那么把模式改为2/2，不仅限制了夫妻双方，也给黑客攻击增加了难度。</li>\n</ul>\n<p>多重签名的设计，让各种业务去中心化充满无限可能。</p>\n<p>（4）亿书的多重签名</p>\n<p><code>多重签名</code>方法在<code>modules/multisignatures.js</code>文件里，类图如下：</p>\n<p><img src=\"//dn-cnode.qbox.me/Fl9Su_riyYM3LBSVZcnj9mLxk0A3\" alt=\"multisignatures-class.png\"></p>\n<p>实现Api的代码如下：</p>\n<pre class=\"prettyprint\"><code>&#x2F;&#x2F; 318行\nrouter.map(shared, {\n  &quot;get &#x2F;pending&quot;: &quot;pending&quot;, &#x2F;&#x2F; Get pending transactions\n  &quot;post &#x2F;sign&quot;: &quot;sign&quot;, &#x2F;&#x2F; Sign transaction\n  &quot;put &#x2F;&quot;: &quot;addMultisignature&quot;, &#x2F;&#x2F; Add multisignature\n  &quot;get &#x2F;accounts&quot;: &quot;getAccounts&quot;\n});\n\n&#x2F;&#x2F; 329行\nlibrary.network.app.use(&#x27;&#x2F;api&#x2F;multisignatures&#x27;, router);\n</code></pre><p>解析一下，最后产生的Api如下：</p>\n<pre class=\"prettyprint\"><code>get &#x2F;api&#x2F;multisignatures&#x2F;pending -&gt; shared.pending &#x2F;&#x2F; 查询等待中的交易\npost &#x2F;api&#x2F;multisignatures&#x2F;sign -&gt; shared.sign &#x2F;&#x2F; 签名交易\nput &#x2F;api&#x2F;multisignatures&#x2F; -&gt; shared.addMultisignature &#x2F;&#x2F; 创建多重签名帐号\nget &#x2F;api&#x2F;multisignatures&#x2F;accounts -&gt; shared.getAccounts &#x2F;&#x2F; 获得关联的帐号（对应者用户私钥）\n</code></pre><p>提供的功能很显然，包括：待交易查询、关联帐号列表查询，用户签名交易，创建多重签名帐号等4个核心功能。我们先从创建多重签名帐号开始，这个Api使用的是http的<code>put</code>方法，对应的自然是<code>更新</code>操作，不查看代码也可以猜想到，该功能应该是在已有帐号基础上的操作，从客户端钱包<code>设置</code>菜单里，可以看到如图操作：</p>\n<p><img src=\"//dn-cnode.qbox.me/Fn8bESMoaWz3rnQAE-OuBD-oy3dD\" alt=\"addMultisignature.png\"></p>\n<p>看看<code>shared.addMultisignature</code>的源代码如下：</p>\n<pre class=\"prettyprint\"><code>&#x2F;&#x2F; modules&#x2F;multisignatures.js文件\nshared.addMultisignature = function (req, cb) {\n\tvar body = req.body;\n\tlibrary.scheme.validate(body, {\n\t\t...\n\n    &#x2F;&#x2F; 732行\n\t\trequired: [&#x27;min&#x27;, &#x27;lifetime&#x27;, &#x27;keysgroup&#x27;, &#x27;secret&#x27;]\n\t}, function (err) {\n\t  ...\n\n\t\tlibrary.balancesSequence.add(function (cb) {\n\t\t\tmodules.accounts.getAccount({publicKey: keypair.publicKey.toString(&#x27;hex&#x27;)}, function (err, account) {\n\t\t\t\t...\n\n        &#x2F;&#x2F; 767行\n\t\t\t\ttry {\n\t\t\t\t\tvar transaction = library.logic.transaction.create({\n\t\t\t\t\t\ttype: TransactionTypes.MULTI, &#x2F;&#x2F; 769行\n\t\t\t\t\t\tsender: account,\n\t\t\t\t\t\tkeypair: keypair,\n\t\t\t\t\t\tsecondKeypair: secondKeypair,\n\t\t\t\t\t\tmin: body.min,\n\t\t\t\t\t\tkeysgroup: body.keysgroup,\n\t\t\t\t\t\tlifetime: body.lifetime\n\t\t\t\t\t});\n\t\t\t\t} catch (e) {\n\t\t\t\t\treturn cb(e.toString());\n\t\t\t\t}\n\n\t\t\t\t...\n};\n</code></pre><p>从732行可知，创建一个多重签名，必须’min’, ‘lifetime’, ‘keysgroup’, 'secret’这四参数（其实，一个默认参数就是当前帐号），min代表上面讲到的<code>m</code>值，即需要确认的人数;lifetime代表生命周期;keysgroup包含多重签名关联的全部帐号，它是数组类型，包含的元素个数就是<code>n</code>;secret是用户密码，与用户私钥对应。</p>\n<p>经过一系列的验证之后，作为一个交易（交易类型TransactionTypes.MULTI，769行）保存到数据库(区款链)里。创建成功的帐号，可以显示多重帐号菜单，对交易进行操作。接下来，自然应该能够查看全部关联的帐号（请看shared.getAccounts方法），查看<code>待确认的交易</code>（请看shared.pending方法），这两个方法仅仅是简单的查询，没什么难度，这里不再浪费篇幅。</p>\n<p>如果用户同意交易，就可以对<code>待确认的交易</code>进行签名（shared.sign方法），这个方法的源码如下：</p>\n<pre class=\"prettyprint\"><code>&#x2F;&#x2F; 586行\nshared.sign = function (req, cb) {\n\tvar body = req.body;\n\tlibrary.scheme.validate(body, {\n\t\t...\n\t\trequired: [&#x27;transactionId&#x27;, &#x27;secret&#x27;]\n\t}, function (err) {\n\t\t...\n\n    &#x2F;&#x2F; 632行\n\t\tfunction done(cb) {\n\t\t\tlibrary.balancesSequence.add(function (cb) {\n        &#x2F;&#x2F; 634行\n\t\t\t\tvar transaction = modules.transactions.getUnconfirmedTransaction(body.transactionId);\n\n\t\t\t\tif (!transaction) {\n\t\t\t\t\treturn cb(&quot;Transaction not found&quot;);\n\t\t\t\t}\n\n        &#x2F;&#x2F; 640行\n\t\t\t\ttransaction.signatures = transaction.signatures || [];\n\t\t\t\ttransaction.signatures.push(sign);\n\n\t\t\t\tlibrary.bus.message(&#x27;signature&#x27;, {\n\t\t\t\t\tsignature: sign,\n\t\t\t\t\ttransaction: transaction.id\n\t\t\t\t}, true);\n\t\t\t\tcb();\n\t\t\t}, function (err) {\n\t\t\t\tif (err) {\n\t\t\t\t\treturn cb(err.toString());\n\t\t\t\t}\n\n\t\t\t\tcb(null, {transactionId: transaction.id});\n\t\t\t});\n\t\t}\n\n\t\t...\n};\n</code></pre><p>这个方法，相比单独的签名方法，不同的是单独的签名方法相当于一个新建交易，而这里的多重签名的用户签名，显然仅仅是对未确认交易（634行）进行签名确认（640行维护了一个签名数组，641行的push方法把用户签名写入数组）。而且，相比独立签名，验证也更复杂，我们将在下一篇《交易》一文中集中讨论验证问题。您也可以结合下一篇的内容，阅读和理解这里的签名方法。</p>\n<h2>总结</h2>\n<p>在加密货币里，每一个交易都涉及到使用私钥签名，用于确认每笔资金所有人。确定了所有人，自然就确定了资金转移的条件、目标和方向，就为我们下一步进行资金转移操作奠定了基础。很自然的，该研究一下亿书的交易了，请看下一篇：<strong>《交易》</strong>。</p>\n<h2>链接</h2>\n<p><strong>本系列文章即时更新，若要掌握最新内容，请关注下面的链接</strong></p>\n<p>本源文地址： <a href=\"https://github.com/imfly/bitcoin-on-nodejs\">https://github.com/imfly/bitcoin-on-nodejs</a></p>\n<p>区块链俱乐部： <a href=\"http://chainclub.org\">http://chainclub.org</a></p>\n<p>亿书官方网站： <a href=\"http://ebookchain.org\">http://ebookchain.org</a></p>\n<p>亿书开发QQ群： 185046161 (亿书为开源项目，欢迎各界小伙伴参与）</p>\n<h2>参考</h2>\n<p><a href=\"http://ebookchain.org/ebookchain.pdf\">亿书白皮书 http://ebookchain.org/ebookchain.pdf</a></p>\n</div>","title":"《Nodejs开发加密货币》之十七：签名和多重签名","last_reply_at":"2016-08-03T03:41:21.599Z","good":false,"top":false,"reply_count":13,"visit_count":631,"create_at":"2016-06-28T03:12:32.603Z","author":{"loginname":"imfly","avatar_url":"https://avatars.githubusercontent.com/u/12215508?v=3&s=120"}},{"id":"57a157265c5423c3352d7b1c","author_id":"5774ca1baffdb83c50b08df2","tab":"ask","content":"<div class=\"markdown-text\"><p>报错信息如下：\n<img src=\"//dn-cnode.qbox.me/Fg6WKDfmzp7Pgoo-gcuNv-fLMkBD\" alt=\"untitled2.png\"></p>\n</div>","title":"node页面console.log(\"汉字\");只要碰到汉字就报错，求解答，谢谢！","last_reply_at":"2016-08-03T03:14:51.705Z","good":false,"top":false,"reply_count":3,"visit_count":158,"create_at":"2016-08-03T02:29:58.520Z","author":{"loginname":"wdlhao","avatar_url":"https://avatars.githubusercontent.com/u/11900691?v=3&s=120"}},{"id":"57a161475c5423c3352d7b21","author_id":"57a160815c5423c3352d7b20","tab":"job","content":"<div class=\"markdown-text\"><p>Frontend Developer Recruitment</p>\n<p>[深圳] Bindo 诚聘 前端开发工程师</p>\n<h4>一站式POS系统</h4>\n<p>Bindo不只是一個銷售點。從簡單易用的庫存管理和條形碼掃描，到強大的報告分析功能，BindoPOS系統設計成為傳統業務一站式的解決方案。拥有數十年零售軟件和電子商貿領域的經驗，我們的團隊研發了BindoPOS系統。簡單易用，適合任何人使用，同時也提供多種特色功能和工具幫您打造生意成功。還等什麼？開始使用Bindo的優化經營方式，並真正做到省錢省時。</p>\n<p>产品主页:</p>\n<p>Bindo POS [<a href=\"https://bindopos.com/\">https://bindopos.com/</a>]</p>\n<h4>岗位职责：</h4>\n<p>负责公司产品前端的开发</p>\n<p>负责公司web mobile的开发</p>\n<h5>岗位要求：</h5>\n<p>三年以上web开发经验</p>\n<p>熟练掌握javascript, 以及HTML5, CSS</p>\n<p>熟练掌握一种或多种javascript前端框架</p>\n<p>对前端开发有浓厚的兴趣</p>\n<p>具备良好的学习能力、问题解决能力、沟通能力和团队合作能力</p>\n<p>开发平台Linux/MacOS</p>\n<h5>加分项：</h5>\n<p>熟悉 React Native, Ionic</p>\n<p>熟悉 ES6</p>\n<p>掌握一门后端编程语言，NodeJS或Ruby</p>\n<p>开源项目的贡献者, github star数目超过50的直接进入CTO面试</p>\n<h4>薪酬福利待遇：</h4>\n<p>工资待遇：至少 20k/m</p>\n<p>五险一金：试用期即为员工缴纳养老保险、医疗保险、失业保险、工伤保险、生育保险及住房公积金</p>\n<p>带薪假期：员工享有带薪年假、婚假等公假</p>\n<p>期权计划：公司会对优秀员工提供期权奖励</p>\n<h4>联系</h4>\n<p>如果有意向或者想具体了解的同学，可以联系 <a href=\"mailto:jobs.frontend@bindo.com\">jobs.frontend@bindo.com</a>，最好贴上 LinkedIn 或者简历 : )</p>\n</div>","title":"[深圳] Bindo 诚聘 前端开发工程师","last_reply_at":"2016-08-03T03:13:11.817Z","good":false,"top":false,"reply_count":0,"visit_count":108,"create_at":"2016-08-03T03:13:11.817Z","author":{"loginname":"levey","avatar_url":"https://avatars.githubusercontent.com/u/629136?v=3&s=120"}},{"id":"57a1603f5621a28b35d1e6b3","author_id":"53929df4c3ee0b5820356140","tab":"share","content":"<div class=\"markdown-text\"><p><a href=\"http://Awesomes.cn\">Awesomes.cn</a> 最新推出了一个板块【我们在用】 <a href=\"https://www.awesomes.cn/weuse\">https://www.awesomes.cn/weuse</a>，用以分享一些前端“”大牛“”他们在使用的框架有哪些，让初学者去参考</p>\n<h3>为什么有这个板块</h3>\n<p>大家可以通过 GitHub 数据了解到某个库的关注度、最后更新时间、趋势等等，这会为我们的选择作为一个重要的参考。</p>\n<p>然而很多时候我关们注了一个库，但是后面却没有真正去使用，或者使用了一段时间后因为某些不好用的问题就放弃使用了。这些数据是不能直观反映出来的，所以我们推出了这个栏目，将用户真正在用的框架标识出来，做一个数据统计，这会是另一个重要的参考因素。</p>\n<h3>如何加入</h3>\n<p>普通用户可以随意加入自己在用的库，但不能展示在该页面，因为这是一个要给所有用户参考的，所以在该栏目上面展示的用户需要具备一定的要求：</p>\n<p>1、GitHub followers 数量 &gt;= 50（需要GiHub方式登录绑定账号）</p>\n<p>2、特殊原因可申请我们的认证（可私信我们的微博 <a href=\"http://weibo.com/awesomescn%EF%BC%89\">http://weibo.com/awesomescn）</a></p>\n<p>具体操作方式请查看  <a href=\"https://www.awesomes.cn/weuserule\">https://www.awesomes.cn/weuserule</a></p>\n<p>我们期待您的分享!!!</p>\n</div>","title":"你在用什么前端框架？","last_reply_at":"2016-08-03T03:08:47.531Z","good":false,"top":false,"reply_count":0,"visit_count":131,"create_at":"2016-08-03T03:08:47.531Z","author":{"loginname":"hxh1246996371","avatar_url":"https://avatars.githubusercontent.com/u/13518855?v=3&s=120"}},{"id":"57a1519253d640a735989b2a","author_id":"56cadbefe1f72315620e1ce6","tab":"ask","content":"<div class=\"markdown-text\"><p><img src=\"//dn-cnode.qbox.me/FnWIee0ty3Uds3N5l0xgAYxRXIPW\" alt=\"QQ图片20160803100351.png\"></p>\n<p>添加之后无法再浏览器打开，第一次用digitalocean，还请大神指教！</p>\n</div>","title":"请问 digitalocean 如何绑定域名？","last_reply_at":"2016-08-03T02:50:31.250Z","good":false,"top":false,"reply_count":2,"visit_count":84,"create_at":"2016-08-03T02:06:10.550Z","author":{"loginname":"TheSixth","avatar_url":"https://avatars.githubusercontent.com/u/13217119?v=3&s=120"}},{"id":"57a152e97a922d6f358cd15d","author_id":"51d37c80d44cbfa304285441","tab":"share","content":"<div class=\"markdown-text\"><pre class=\"prettyprint\"><code>var User = db.define(&#x27;user&#x27;, {\n    username: {type: Sequelize.STRING, allowNull: false, unique: &#x27;compositeIndex&#x27;},\n    password: {type: Sequelize.STRING, allowNull: false, },\n    lastAt: {type: Sequelize.DATE, allowNull: false, defaultValue: Sequelize.NOW,},\n    roleType: {\n        type:   Sequelize.INTEGER,\n        allowNull: false,\n        defaultValue: Enumeration.roleType[3].value,\n\n    },\n},{\n    indexes: [\n        &#x2F;&#x2F; Create a unique index on username,password\n        {\n            unique: true,\n            fields: [&#x27;username&#x27;,&#x27;password&#x27;]\n        }\n    ],\n    getterMethods   : {\n        roleTypeTitle : function() { return Enumeration.roleType[this.roleType].title },\n        lastAtFormat : function() { return tools.formatDate(this.lastAt) },\n        createdAtFormat: function() { return tools.formatDate(this.createdAt) },\n        updatedAtFormat: function() { return tools.formatDate(this.updatedAt) },\n    },\n})\n\n</code></pre><pre class=\"prettyprint\"><code>var User = db.define(&#x27;user&#x27;, {\n    username: {type: Sequelize.STRING, allowNull: false, unique: &#x27;compositeIndex&#x27;},\n    password: {type: Sequelize.STRING, allowNull: false, },\n    lastAt: {type: Sequelize.DATE, allowNull: false, defaultValue: Sequelize.NOW,},\n    roleType: {\n        type:   Sequelize.INTEGER,\n        allowNull: false,\n        defaultValue: Enumeration.roleType[3].value,\n\n    },\n},{\n    indexes: [\n        &#x2F;&#x2F; Create a unique index on username,password\n        {\n            unique: true,\n            fields: [&#x27;username&#x27;,&#x27;password&#x27;]\n        }\n    ],\n    getterMethods   : {\n        roleTypeTitle : () =&gt; Enumeration.roleType[this.roleType].title,\n        lastAtFormat :  () =&gt;  tools.formatDate(this.lastAt) ,\n        createdAtFormat:  () =&gt; tools.formatDate(this.createdAt) ,\n        updatedAtFormat:  () =&gt; tools.formatDate(this.updatedAt) ,\n    },\n})\n\n</code></pre><p>以上两段代码，折腾了一个晚上，第二段代码 使用es6的写法， 里面的this 对象 和 第一段代码中的this 对象不一样的。</p>\n<p>请问，这里的getterMethods 如果用 es6的 写法，怎样去获取原来的那个this？</p>\n</div>","title":"sequelize 上遇到的一些坑","last_reply_at":"2016-08-03T02:50:24.497Z","good":false,"top":false,"reply_count":3,"visit_count":94,"create_at":"2016-08-03T02:11:53.068Z","author":{"loginname":"thomas0836","avatar_url":"//gravatar.com/avatar/b62fb4edd06b28eb30c575af5fed1c61?size=48"}},{"id":"57a03d87632442d2436f7982","author_id":"57a03d09632442d2436f7981","tab":"ask","content":"<div class=\"markdown-text\"><p>大家好,今天开一个Nodejs的库,发现很多代码在前后端都会使用,但是前端是没有require和 module.exports 的.\n但是并没有报错. 请问这是使用了什么方法? 谢谢</p>\n</div>","title":"NodeJs 的代码是如何在浏览器中使用的?","last_reply_at":"2016-08-03T02:31:00.497Z","good":false,"top":false,"reply_count":4,"visit_count":307,"create_at":"2016-08-02T06:28:23.113Z","author":{"loginname":"lilijreey","avatar_url":"https://avatars.githubusercontent.com/u/1732373?v=3&s=120"}},{"id":"57a00b7160adfb1f1db8429b","author_id":"548662b31bd3c71762df05dc","tab":"ask","content":"<div class=\"markdown-text\"><p>原来都是用java做产品，这次尝试用nodejs做了一个新项目</p>\n<p>现在问题来了，我们产品是刻光盘卖给各个用户的，用户自己提供服务器，我们安装。\n以前java，是通过硬件（加密狗）的方式，但是nodejs现在对机密狗的支持还没找到。尝试了软加密，但是无论如何，加解密过程都一定会在代码中体现，只要用户有想法就能破解。\n有什么其他办法解决这个问题吗，用户的服务器是没有外网的，所以通过我们云服务验证也不行。</p>\n<p>说白了就是怎么防止nodejs程序卖给一个人就等于开源了。。</p>\n</div>","title":"nodejs如何加密","last_reply_at":"2016-08-03T02:24:26.108Z","good":false,"top":false,"reply_count":7,"visit_count":243,"create_at":"2016-08-02T02:54:41.447Z","author":{"loginname":"zhounanbin","avatar_url":"https://avatars.githubusercontent.com/u/4066179?v=3&s=120"}},{"id":"57a04f5dd974dd97432200c4","author_id":"579daef823e454cd2af817c7","tab":"job","content":"<div class=\"markdown-text\"><p>我们是一家互联网金融科技公司，崇尚技术创新、尊重技术人才；我们要用最好技术和人才引领“互助”行业发展、保障亿万中国家庭！目前已获得 5000 万元天使投资，由 IDG 、高榕资本、腾讯、新美大、点亮基金、真格基金等联合投资。\n联系方式： <a href=\"mailto:hr@shuidihuzhu.com\">hr@shuidihuzhu.com</a>  (邮件格式：姓名-岗位-cnode社区)\n工作地点：北京市朝阳区望京 SOHO\n薪资待遇：20K-30K</p>\n<p>工作职责：\n1 、水滴互助产品的微信、 App 内的 H5 端研发\n2 、水滴爱心筹产品的微信、 App 内的 H5 端研发\n3 、公司官网的研发\n4 、前后端分离的开发框架搭建、升级</p>\n<p>职位要求:\n1 、至少 3 年 WEB 前端项目开发经验， 1 年以上 HTML5/CSS3 移动端开发经验\n2 、扎实的 coding 功底，能够迅速对需求建模并转化为代码\n3 、良好的表达沟通与协作能力，学习能力强， 有优秀的逻辑思维能力\n4 、精通常规 WEB 前端开发技能（ HTML/CSS/Javascript ）\n5 、精通前端开发常用技术（如 AJAX ），能够熟练使用 jQuery 等 JS 库实现页面逻辑\n6 、熟练使用 bootstrap 等 UI 框架快速开发页面原型\n7 、精通面向对象设计方法，对重构与模式有深刻理解\n8 、熟悉 W3C 标准，对表现与数据分离和 web 语义化有深刻理解\n9 、了解 Angular.js/React.js/Vue.js 等前端 MV*框架者优先\n10 、熟悉 nodeJs ， PHP ， JAVA 或其他后端语言优先</p>\n<p>我们在寻找符合以下特质的创业伙伴：\n1 、技术卓越，关心并能深入业务\n2 、结果导向，找方法去达成结果，而不是找借口\n3 、决心创业，用今天的付出去投资未来，直面各种困难\n4 、渴求成长，足够努力的提升自己以适应业务的 高速发展</p>\n</div>","title":"【北京】【水滴互助】我们在寻找有创业激情的前端工程师 20K-30K 高期权","last_reply_at":"2016-08-03T02:15:03.114Z","good":false,"top":false,"reply_count":2,"visit_count":196,"create_at":"2016-08-02T07:44:29.392Z","author":{"loginname":"shuidihuzhu123","avatar_url":"https://avatars.githubusercontent.com/u/20750784?v=3&s=120"}},{"id":"57a083c7b1fb48b34306f70a","author_id":"54ed583a13a640c2725d8560","tab":"share","content":"<div class=\"markdown-text\"><h1>vue-storage</h1>\n<hr>\n<h2>重要的事情说三遍，该中间件基于proxy实现，该中间件基于proxy实现，该中间件基于proxy实现。目前没有babel的prefill</h2>\n<hr>\n<p>基于sessionStorage,localStorage的vue插件,让本地存储与$data数据关联,\n目的是让大家在vue上更方便的使用本地存储.</p>\n<h2>usage</h2>\n<h3>expample</h3>\n<p>运行:<code>npm install; npm run build</code></p>\n<p><a href=\"https://weivea.github.io/vue-storage/\">在线预览</a></p>\n<h3>install</h3>\n<pre class=\"prettyprint\"><code>npm install vue-storage-weivea\n\n</code></pre><p>话说现npm也需要namespace了呢</p>\n<h3>use</h3>\n<p>root.js</p>\n<pre class=\"prettyprint\"><code>import Vue from &#x27;vue&#x27;\nimport vueStorage from&#x27;.&#x2F;vue-storage&#x2F;index&#x27;\nimport app from &#x27;.&#x2F;app.vue&#x27;\n\nVue.use(vueStorage);\n\nwindow.appVue =  new Vue({\n  el: &#x27;#container&#x27;,\n  components: { app }\n});\n</code></pre><p>app.vue</p>\n<pre class=\"prettyprint\"><code>import sub from &#x27;.&#x2F;sub.vue&#x27;\nexport default {\n        data(){\n            return{\n                session:{\n                    form:{\n                        a:1,\n                        b:2\n                    }\n                },\n                storagea:{\n                    c:3,\n                    d:5\n                }\n            }\n        },\n        created(){\n            &#x2F;&#x2F;sessionStorage\n            this.session = this.$sessionBind(this.session);\n            &#x2F;&#x2F;localStorage\n            this.storagea = this.$storageBind(this.storagea);\n        },\n        components:{\n            sub:sub\n        }\n    }\n</code></pre><p>sub.vue</p>\n<pre class=\"prettyprint\"><code>export default {\n        data(){\n            return{\n                session:{\n                    form:{\n                        a:null,\n                        b:null\n                    },\n\n                    list:[]\n                }\n            }\n        },\n        created(){\n            this.session = this.$sessionBind(this.session);\n        },\n        methods:{\n            addOne:function () {\n                this.session.list.push(1);\n                this.session.$saveData();&#x2F;&#x2F;主动save\n            }\n        }\n    }\n</code></pre><h2>desc</h2>\n<ul>\n<li><code>this.$sessionBind(this.session)</code>入参必须是json风格的对象;</li>\n<li>每个component只能bind一个对象;</li>\n<li>这是一把双刃剑,滥用会影响应用性能,所以请用在必要数据上边,最好一个应用只在$root层面使用.</li>\n</ul>\n</div>","title":"vue-storage","last_reply_at":"2016-08-03T02:13:22.756Z","good":false,"top":false,"reply_count":2,"visit_count":145,"create_at":"2016-08-02T11:28:07.575Z","author":{"loginname":"weivea","avatar_url":"https://avatars.githubusercontent.com/u/8197845?v=3&s=120"}},{"id":"5798288a4cddcb432614682b","author_id":"54280fece923fce9114e62ee","tab":"job","content":"<div class=\"markdown-text\"><p><a href=\"https://youzan.com\">有赞</a>是一家快速发展的移动零售服务商，你粗粗地可以理解为微信、微博、手机APP、手机浏览器上的淘宝，我们更淘宝不一样的地方是：我们致力于打造去中心化的电商平台。具体你可以看这篇文章了解。罗辑思维、央广购物，甚至微信官方的维新派都在使用我们的平台管理粉丝和移动电商业务。</p>\n<p>公司由前支付宝首席交互设计师白鸦创立，公司介绍可以看http://www.youzan.com 。</p>\n<p>我们前端团队快30 多人了， 我们非常重视技术积累和新技术演进。我们非常欢迎：基础好、勤奋、对代码有追求的同学的加入（对于一个 Coder 来说这就够了）。</p>\n<p>前端岗位要求，具体见<a href=\"http://job.youzan.com/#5\">这里</a>：</p>\n<ol>\n<li>本科及以上学历;</li>\n<li>扎实的计算机以及网络基础；</li>\n<li>阅读英文技术文档和书籍无障碍；</li>\n<li>HTML、CSS、JavaScript 基础扎实，了解 HTTP 协议以及浏览器原理；</li>\n<li>熟悉 jQuery、Backbone、Zepto、React 等常见框架;</li>\n<li>了解PHP、Java、Python 等后端语言中至少一种;</li>\n</ol>\n<p>Nodejs岗位要求，具体见<a href=\"http://job.youzan.com/#87\">这里</a>：</p>\n<ol>\n<li>扎实的操作系统、网络、数据结构、面向对象等计算机基础；</li>\n<li>熟悉RESTFUL，了解TCP/IP、RPC、SOCKET、WEB SOCKET等通讯协议；</li>\n<li>熟悉koa、Express等常用的node框架；</li>\n<li>熟悉Mysql数据库，熟悉Redis、memcached等缓存优化；</li>\n<li>HTML、CSS、JavaScript 基础扎实，了解 HTTP 协议以及浏览器原理;</li>\n<li>熟练运用Node.js, React, Redux, ES6, Webpack等；</li>\n<li>熟练使用linux、git</li>\n</ol>\n<p>找合适的人，做牛逼的事!\n如果有兴趣请发我简历：jinfeng@youzan.com\n当然我们不只招前端和node，还招后端，数据等职位，详见：<a href=\"http://job.youzan.com/\">http://job.youzan.com/</a></p>\n</div>","title":"[杭州] 杭州有赞 招聘 前端工程师 及 Nodejs工程师 (15-30K)","last_reply_at":"2016-08-03T02:12:21.362Z","good":false,"top":false,"reply_count":10,"visit_count":820,"create_at":"2016-07-27T03:20:42.414Z","author":{"loginname":"jinphen","avatar_url":"https://avatars.githubusercontent.com/u/4998074?v=3&s=120"}},{"id":"57a14f2d5c5423c3352d7b15","author_id":"57a058399349f87943a83c85","tab":"job","content":"<div class=\"markdown-text\"><p>来！来！！我们先来谈谈理想（我们是做什么的，这很重要）\nArtden是一家专注于原创艺术与生活美学的互联网科技公司，2015年在中国深圳成立（初创团队，年轻又充满活力）。\nArtden旨在为有品味的消费者和创作家提供最好的一站式解决方案，为消费者提供质量优选和选择自由度高的原创设计产品，为创作家提供简易快捷的创作渠道与平台。</p>\n<p>【我们的实力】\n老板是来自哥伦比亚大学的海归学霸、技术前沿、启动资金雄厚、引领新艺术潮流。\n需要技术舞台发挥的，看过来！\n无处安放你的技术才华，这里来！\n五天工作制，哇~~~快快来！\n【我们需要你】\n有理想，不求你拯救世界，但你要有自己的人生规划；\n有热情，你的人生每一天都打满鸡血；\n有想法，不要吝惜说出来，我们需要你的大胆和创新；\n聪明，自信，超强的学习能力，对技术特别热爱（这辈子与技术相约的我们喜欢），有事没事喜欢研究新技术的你（给我来一打）。\n能够流畅阅读英文技术文档的你，有良好编程习惯（最好是有代码洁癖）的你。\n一个有意思的你。\n最最最重要的是有自我驱动力，能够自主高效高质量完成任务的你。</p>\n<p>【你要做什么】</p>\n<p>你要管我们公司产品后端开发；\n配合我们的项目经理，高质高效的完成项目经理安排的各种各样的工作；\n我们的新功能需求、设计与接口文档编写也得有你的份儿！\n你还要与前端的程序员小哥哥们合作实现功能并优化我们的系统～\n【我们寻找的人】\n你得有服务端开发经验, 在项目中使用过主流的js框架进行开发;如果你过去熟悉Node.js框架、常用Node.js扩展、事件驱动和异步编程思想我们会优先考虑；\n熟悉NoSQL数据库者优先（Redis, MongoDB）；\n你的优点……一定是代码风格棒，注释习惯好！\n你还要有Linux开发和部署经验；\n一定要有很强的责任感哦，表达能力、沟通能力和学习能力一样都不能少，对未知的问题有兴趣，并且还能够努力去解决哦！</p>\n<p>如果你是我们要寻找的人，不要犹豫请将你的简历并附上个人近期作品（技术博客、代码、技术笔记…各种能充分展现你的牛逼技术）发给我们\n【来这里】\n1、有迈科龙集团雄厚的财力支持！\n2、让我们看看你的实力，工资绝对让你满意；\n3、不交五险一金的公司都是耍流氓；\n4、 随时都是下午茶时光，我们的零食无限供应，想吃就去拿！咖啡机随便使，茶水饮料酸奶随便喝。没有你喜欢的零食？没关系，想吃啥，告诉行政妹纸，我们都买！\n5、一群逗逼同事，欢乐的午餐时光，我们一起谈谈银森，老司机即将开车，请系好安全带！\n6、不定期公司聚会聚餐，吃好喝好才能好好工作！</p>\n<p>我在这，你在哪？？？？\n感兴趣的朋友不要犹豫请将你的简历并附上个人近期作品（技术博客、技术笔记…各种能充分展现你的牛逼技术）发给我们！\n勾搭方式：hr@iyzsh.com ，又或微信：pengmeikuang\n<img src=\"//dn-cnode.qbox.me/FkLzo4TRNry3MaYDxpMn_hKFrh6i\" alt=\"53FLLZ0X51N_LTBPO%HUCUI.png\">\n<img src=\"//dn-cnode.qbox.me/FnbDM-WEklCHeqpEXLsSPua5HPgw\" alt=\"JRI%YPOQU$G){J}M71{T__G.png\">\n<img src=\"//dn-cnode.qbox.me/FqQPfGwFqZJr3226Cfmo8_AxGy_b\" alt=\"L~522%2RS2(R9HZCOIH(ABU.png\">\n![X7HUYZ}J1PVW4_Z]IS<a href=\"//dn-cnode.qbox.me/FsBoGPLab9a4rDseLkqsX0yMROgo\">Z5OF.png</a></p>\n</div>","title":"[深圳] Artden艺生活招聘 Node.js 程序员，诱人的发展前景等你来挑战","last_reply_at":"2016-08-03T01:55:57.137Z","good":false,"top":false,"reply_count":0,"visit_count":95,"create_at":"2016-08-03T01:55:57.137Z","author":{"loginname":"Jancy-peng","avatar_url":"https://avatars.githubusercontent.com/u/20785227?v=3&s=120"}},{"id":"57a14db97a922d6f358cd15c","author_id":"57a138415c5423c3352d7b14","tab":"share","content":"<div class=\"markdown-text\"><p>第一次写了一个完整的小项目(js和node)，可能里面还有很多要调试的地方，也没有作网站安全方面的考虑，后期会全部加上。\n<img src=\"http://7xsn9b.com1.z0.glb.clouddn.com/blog.gif\" alt=\"动态效果演示\">\n动态效果如果图片太大看不见可以看这个<a href=\"http://7xsn9b.com1.z0.glb.clouddn.com/blog.gif\">动态效果演示</a>或者去github的Readme上也有\n详细文档说明进<a href=\"https://github.com/chickencyj/blog-by-nodejs\">Github传送门</a></p>\n</div>","title":"前端新手，最近在自学中用express+mongoose写了个博客，求轻喷○|￣|-_","last_reply_at":"2016-08-03T01:49:45.012Z","good":false,"top":false,"reply_count":0,"visit_count":128,"create_at":"2016-08-03T01:49:45.012Z","author":{"loginname":"chickencyj","avatar_url":"https://avatars.githubusercontent.com/u/16118189?v=3&s=120"}},{"id":"579d7261da05b9e92af3258b","author_id":"53ac16d8c3ee0b5820b8fcff","tab":"share","content":"<div class=\"markdown-text\"><p>直播的内容如下：</p>\n<ol>\n<li>平时会研究一些新的工具，比如docker啊，elastic search啊，iOS或者安卓的一些有趣的库啊之类的。</li>\n<li>可以应水友的要求，演示一些代码编写。</li>\n<li>如果水友想了解某个工具，但又懒得自己去研究，可以向我提出，有趣的话我会直播研究。</li>\n</ol>\n<p>直播时间：\n每周一三五晚8：00~10：30</p>\n<p>有兴趣的人欢迎来看哈，直播地址：\n<a href=\"http://www.douyu.com/kilik52\">http://www.douyu.com/kilik52</a></p>\n<p>个人介绍：\n技术栈：\niOS（OBJC，swift）、安卓（JAVA）、NodeJS、 AngularJS</p>\n<p>自己开了个公司做自主产品和外包。 平时没有维护什么开源库什么的。不过有一个产品：\n<a href=\"http://shaozi.info\">http://shaozi.info</a>， 这个产品的前端、后端、iOS和安卓都是我一个人开发的（后来招了两个人用来加快进度）</p>\n</div>","title":"打算直播编程，不知道有没有人有兴趣","last_reply_at":"2016-08-03T01:40:33.541Z","good":false,"top":false,"reply_count":10,"visit_count":721,"create_at":"2016-07-31T03:37:05.660Z","author":{"loginname":"kilik52","avatar_url":"https://avatars.githubusercontent.com/u/37238?v=3&s=120"}},{"id":"56067a16272b724e5efefcce","author_id":"56067687148959375f34ff30","tab":"ask","content":"<div class=\"markdown-text\"><p>花了些时间初步了解了nodejs 和express 的运作方式.这几天准备做一个小的项目,在考虑到权限问题的时候却被卡住了.</p>\n<p>我的需求是这样的. 单纯的用户认证这个应该很简单,passport这些都能胜任… 但是我想做的是针对每个请求URL进行权限控制.比如针对普通用户,</p>\n<p>普通用户可以访问/user/updateSelf ,不能访问/user/addUser,而作为管理员可以访问任何一个链接. 这是第一方面</p>\n<p>另外一方面,因为express也支持 restful的请求, 类似/user/:userId, /user/:action/:data ,如果采用这样的写法, 那么后台实际定义的URL是上面写的这样, 而接收过来的请求</p>\n<p>URL 可能是 /user/12 , /user/save/u3 , 针对这样的URL 我又该怎么进行权限的控制呢.</p>\n<p>我打算将所有定义的URL都和数据中的角色表进行映射, 比如 admin 对应 [/user/:userId,/user/:action/:data] 而普通用户角色 user对应 [/user/:userId]</p>\n<p>那么 对于这样的路由 app.get(’/user/:action/:data’,function(res,req,next){…}) user就不会有权限访问.</p>\n<p>但是我又该如何在处理请求之前获取 这些实际的url 诸如 /user/1 对应的是 /user/:userId 这个Url呢?</p>\n<p>java中有反射,并且像struts这样的框架提供了拦截器,在执行action之前可以反射获取待执行的action,然后在判断URL和角色有无权限. 在nodejs中有这样的办法吗?</p>\n<p>有人有好的办法吗 或者 有没有其他的权限控制框架.  让我不用为每个路由去配置权限. 而只要通过aop的方式,在执行所有的路由方法之前 判断权限?</p>\n</div>","title":"新手刚学nodejs 关于express的权限控制有问题请教各位大神","last_reply_at":"2016-08-03T01:34:47.006Z","good":false,"top":false,"reply_count":18,"visit_count":2469,"create_at":"2015-09-26T10:57:26.062Z","author":{"loginname":"HengCC","avatar_url":"https://avatars.githubusercontent.com/u/6167532?v=3&s=120"}},{"id":"576dfe22bef3ca5c17dedfa5","author_id":"576dfc54bef3ca5c17dedfa4","tab":"share","content":"<div class=\"markdown-text\"><p><img src=\"//dn-cnode.qbox.me/Fq4GOPwhkgv6SqTB1srnnih9Y6I5\" alt=\"nodejs-cover.PNG\"></p>\n<p>一些视频的链接，视频放在优酷，现在录制到 11 集，模块机制部分。\n希望大家多多指正</p>\n<p><img src=\"//dn-cnode.qbox.me/FpZsbLxhuArZVlgyCWA4WQsz8IpC\" alt=\"nodejs-list.PNG\"></p>\n</div>","title":"最近录了些nodjs视频，适合入门，望大家多多指正，以便改善","last_reply_at":"2016-08-03T00:02:01.548Z","good":false,"top":false,"reply_count":27,"visit_count":1885,"create_at":"2016-06-25T03:44:34.337Z","author":{"loginname":"zideajang","avatar_url":"https://avatars.githubusercontent.com/u/13171516?v=3&s=120"}},{"id":"5792df464cddcb432614671a","author_id":"576dfc54bef3ca5c17dedfa4","tab":"share","content":"<div class=\"markdown-text\"><p>在最近的课程分享，我分享了 csurf 模块 以及如何使用 passport 开进行注册和登录验证\n<img src=\"//dn-cnode.qbox.me/Fohk62Kl05vvbxUpNoo8bKH2BJfi\" alt=\"passport-and-csurf.JPG\"></p>\n</div>","title":"分享一个我的购物车教程","last_reply_at":"2016-08-03T00:00:18.715Z","good":false,"top":false,"reply_count":10,"visit_count":613,"create_at":"2016-07-23T03:06:46.403Z","author":{"loginname":"zideajang","avatar_url":"https://avatars.githubusercontent.com/u/13171516?v=3&s=120"}},{"id":"57a133b95621a28b35d1e6a0","author_id":"576dfc54bef3ca5c17dedfa4","tab":"share","content":"<div class=\"markdown-text\"><p>分享 ES6 的新特性详解\nes6 已经广泛地被应用到 angular2 react koa 中\n这是本人分享学习视频，希望多多指正</p>\n<p><a href=\"http://i.youku.com/i/UMzY5ODgxNTM3Mg==?previewpage=1\">http://i.youku.com/i/UMzY5ODgxNTM3Mg==?previewpage=1</a><img src=\"//dn-cnode.qbox.me/FuKIdYUJxdiDv2NGyEBLKHHHJeEo\" alt=\"es6_list.png\"></p>\n</div>","title":"分享 ES6 的新特性详解","last_reply_at":"2016-08-02T23:58:49.557Z","good":false,"top":false,"reply_count":0,"visit_count":133,"create_at":"2016-08-02T23:58:49.557Z","author":{"loginname":"zideajang","avatar_url":"https://avatars.githubusercontent.com/u/13171516?v=3&s=120"}},{"id":"578d8a33b78759e813a57a34","author_id":"578d838d992ec53c1467676f","tab":"job","content":"<div class=\"markdown-text\"><ol>\n<li></li>\n</ol>\n<ul>\n<li></li>\n</ul>\n<p>来自酷炫的 <a href=\"https://github.com/TakWolf/CNode-Material-Design\">CNodeMD</a></p>\n</div>","title":"android6.0权限有哪些改变？","last_reply_at":"2016-08-02T19:58:59.052Z","good":false,"top":false,"reply_count":1,"visit_count":193,"create_at":"2016-07-19T02:02:27.256Z","author":{"loginname":"sushanqiang","avatar_url":"https://avatars.githubusercontent.com/u/14903295?v=3&s=120"}},{"id":"57a0a7e8632442d2436f79a4","author_id":"57a053f99349f87943a83c83","tab":"share","content":"<div class=\"markdown-text\"><p>其实是想安利 <a href=\"https://css.hanzi.co/\">汉字标准格式</a> 这个汉字排版框架。问题在于页面加载渲染的时候还是有点卡，尤其是页面元素比较多的时候，有的浏览器甚至会崩。</p>\n<p>于是我写了个 Hexo 插件，在服务器端完成渲染，浏览器端就不需要引用它的 js 文件了。效果好，速度还快。<br>\n<a href=\"https://github.com/lujjjh/hexo-hanzi\">GitHub 传送门</a></p>\n<p>渲染效果可以参见  <a href=\"https://codehut.me/\">我的博客</a>。我比较在意的是中西文间隙、标点符号修正、标点符号挤压和标点符号悬挂这几点，着重号之类的不怎么用，音标什么的就更不用说了。</p>\n<p>关于 Unicode 编码下中西文标点符号的坑，欢迎移步之前写的<a href=\"https://codehut.me/2016/07/25/use-hanzi-to-typeset-hanzi-better/#%E4%B8%AD%E8%A5%BF%E6%96%87%E7%9A%84%E6%A0%87%E7%82%B9%E7%AC%A6%E5%8F%B7\">《使用 “汉字标准格式” 更好地排版中文》</a>。</p>\n<p>如果想用在自己的应用里也没问题，我把渲染的部分提取出来发布成单独的 package 了。<br>\n<a href=\"https://github.com/lujjjh/node-han-css\">又一个 GitHub 传送门</a></p>\n<p>CNode 的第一帖，求测试和拍砖。</p>\n<p>另外，CNode 的字体族回退有点问题，<code>&lt;body&gt;</code> 的 <code>font-family</code> 没有做无衬线体（sans-serif）的回退，导致没有前面几个字体的系统下回退到了衬线体，不知能否修复。</p>\n</div>","title":"印刷品般的 Hexo","last_reply_at":"2016-08-02T16:07:46.770Z","good":false,"top":false,"reply_count":1,"visit_count":218,"create_at":"2016-08-02T14:02:16.047Z","author":{"loginname":"lujjjh","avatar_url":"https://avatars.githubusercontent.com/u/3000535?v=3&s=120"}},{"id":"5797029c4265959826e7b2c2","author_id":"55afa32c9594740e76ab3e2e","tab":"share","content":"<div class=\"markdown-text\"><p><a href=\"https://github.com/dou4cc/drool\">https://github.com/dou4cc/drool</a>\n2016/08/02 - 更新了readme，详讲了要开浏览器的哪些实验选项才能运行demo。\n欢迎回复。</p>\n</div>","title":"设计了一门轻量标记语言——drool","last_reply_at":"2016-08-02T12:14:43.441Z","good":false,"top":false,"reply_count":8,"visit_count":576,"create_at":"2016-07-26T06:26:36.959Z","author":{"loginname":"dou4cc","avatar_url":"https://avatars.githubusercontent.com/u/7764678?v=3&s=120"}},{"id":"56e688a983cbb63b6d120300","author_id":"541bf946ad60405c1f14b770","tab":"share","content":"<div class=\"markdown-text\"><h1>koa</h1>\n<p>转载：原文来自 <a href=\"https://github.com/berwin/Blog/issues/8\">https://github.com/berwin/Blog/issues/8</a></p>\n<p>学习koa需要一些相关知识，有两个关键词</p>\n<ul>\n<li>generator</li>\n<li>promise</li>\n</ul>\n<p>本文主要针对koa的原理进行讨论，属于深度篇，并不会对koa的使用过多介绍。</p>\n<p>如果在阅读过程中，发现有哪些地方我写的不太清楚，不容易理解，希望能提出，我会参考建议并进行修改~~</p>\n<h2>koa总体流程图</h2>\n<p>让我们从一张图开始</p>\n<img src=\"http://berwin.github.io/ppts/koa/img/koa-flow.jpg\" width=\"100%\">\n<p>上图中，详细说明了koa从启动server之前，到接受请求在到响应请求的过程中，经历了哪些步骤。</p>\n<p>那我们按照时间线说起~</p>\n<h2>启动前</h2>\n<p>图中有三个蓝色的方块，分别代表三个<code>静态类</code>。</p>\n<p>什么是<code>静态类</code>？这个是我自己给起的名，哈哈</p>\n<p><code>静态类</code>就是程序运行前就存在的方法集合，<code>动态类</code>就是通过代码生成出的方法集合。额，都是我自己起的名，概念也是我自己琢磨的，就是简单归个类。</p>\n<p>三个静态类分别是<code>Request</code>，<code>Context</code>，<code>Response</code></p>\n<p><strong>Request</strong></p>\n<p>Request中包含了一些操作 Node原生请求对象的非常有用的方法。例如获取query数据，获取请求url等，更多方法去查API</p>\n<p><strong>Response</strong></p>\n<p>Response中包含了一些用于设置状态码啦，主体数据啦，header啦，等一些用于操作响应请求的方法。更多方法去查API</p>\n<p><strong>Context</strong></p>\n<p>Context是koa中最重要的概念之一，Context字面意思是上下文，也有环境等意思，koa中的操作都是基于这个context进行的，例如</p>\n<pre class=\"prettyprint language-javascript\"><code>this.body = &#x27;hello world&#x27;;\n</code></pre><p>从前面的图中，启动前的三个蓝色方块可以看到，左边的Request和右边的Response各有一个箭头指向Context，表示Request和Response自身的方法会委托到Context中。</p>\n<p>Context中有两部分，一部分是自身属性，主要是应用于框架内部使用，一部分是Request和Response委托的操作方法，主要为提供给用户更方便从Request获取想要的参数和更方便的设置Response内容。</p>\n<p>下面是Context源码片段。</p>\n<pre class=\"prettyprint language-javascript\"><code>var delegate = require(&#x27;delegates&#x27;);\nvar proto = module.exports = {}; &#x2F;&#x2F; 一些自身方法，被我删了\n\n&#x2F;**\n * Response delegation.\n *&#x2F;\n\ndelegate(proto, &#x27;response&#x27;)\n  .method(&#x27;attachment&#x27;)\n  .method(&#x27;redirect&#x27;)\n  .method(&#x27;remove&#x27;)\n  .method(&#x27;vary&#x27;)\n  .method(&#x27;set&#x27;)\n  .method(&#x27;append&#x27;)\n  .access(&#x27;status&#x27;)\n  .access(&#x27;message&#x27;)\n  .access(&#x27;body&#x27;)\n  .access(&#x27;length&#x27;)\n  .access(&#x27;type&#x27;)\n  .access(&#x27;lastModified&#x27;)\n  .access(&#x27;etag&#x27;)\n  .getter(&#x27;headerSent&#x27;)\n  .getter(&#x27;writable&#x27;);\n\n&#x2F;**\n * Request delegation.\n *&#x2F;\n\ndelegate(proto, &#x27;request&#x27;)\n  .method(&#x27;acceptsLanguages&#x27;)\n  .method(&#x27;acceptsEncodings&#x27;)\n  .method(&#x27;acceptsCharsets&#x27;)\n  .method(&#x27;accepts&#x27;)\n  .method(&#x27;get&#x27;)\n  .method(&#x27;is&#x27;)\n  .access(&#x27;querystring&#x27;)\n  .access(&#x27;idempotent&#x27;)\n  .access(&#x27;socket&#x27;)\n  .access(&#x27;search&#x27;)\n  .access(&#x27;method&#x27;)\n  .access(&#x27;query&#x27;)\n  .access(&#x27;path&#x27;)\n  .access(&#x27;url&#x27;)\n  .getter(&#x27;origin&#x27;)\n  .getter(&#x27;href&#x27;)\n  .getter(&#x27;subdomains&#x27;)\n  .getter(&#x27;protocol&#x27;)\n  .getter(&#x27;host&#x27;)\n  .getter(&#x27;hostname&#x27;)\n  .getter(&#x27;header&#x27;)\n  .getter(&#x27;headers&#x27;)\n  .getter(&#x27;secure&#x27;)\n  .getter(&#x27;stale&#x27;)\n  .getter(&#x27;fresh&#x27;)\n  .getter(&#x27;ips&#x27;)\n  .getter(&#x27;ip&#x27;);\n</code></pre><p>delegates是第三方npm包，功能就是把一个对象上的方法，属性委托到另一个对象上</p>\n<p>对了，你猜对了，上面那一排方法，都是Request和Response静态类中的方法，有点看目录的感觉~</p>\n<p>method方法是委托方法，getter方法用来委托getter，access方法委托getter+setter</p>\n<p>下面是源码片段</p>\n<pre class=\"prettyprint language-javascript\"><code>function Delegator(proto, target) {\n  if (!(this instanceof Delegator)) return new Delegator(proto, target);\n  this.proto = proto;\n  this.target = target;\n  this.methods = [];\n  this.getters = [];\n  this.setters = [];\n  this.fluents = [];\n}\n\nDelegator.prototype.method = function(name){\n  var proto = this.proto;\n  var target = this.target;\n  this.methods.push(name);\n\n  proto[name] = function(){\n    return this[target][name].apply(this[target], arguments);\n  };\n\n  return this;\n};\n</code></pre><p>从上面的代码中可以看到，它其实是在proto上新建一个与Request和Response上的方法名一样的函数，然后执行这个函数的时候，这个函数在去Request和Response上去找对应的方法并执行。</p>\n<p>简单来个栗子</p>\n<pre class=\"prettyprint language-javascript\"><code>var proto = {};\n\nvar Request = {\n  test: function () {\n    console.log(&#x27;test&#x27;);\n  }\n};\n\nvar name = &#x27;test&#x27;;\nproto[name] = function () {\n  return Request[name].apply(Request, arguments);\n};\n</code></pre><p>我们在来看看getter方法</p>\n<pre class=\"prettyprint language-javascript\"><code>Delegator.prototype.getter = function(name){\n  var proto = this.proto;\n  var target = this.target;\n  this.getters.push(name);\n\n  proto.__defineGetter__(name, function(){\n    return this[target][name];\n  });\n\n  return this;\n};\n</code></pre><p>可以看到，在proto上绑定个getter函数，当函数被触发的时候去，会去对应的request或response中去读取对应的属性，这样request或response的getter同样会被触发~</p>\n<p>我们在来看看access</p>\n<pre class=\"prettyprint language-javascript\"><code>Delegator.prototype.access = function(name){\n  return this.getter(name).setter(name);\n};\n</code></pre><p>可以看到，这个方法是getter+setter，getter上面刚说过，setter与getter同理，不多说了，心好累…</p>\n<p>应用启动前的内容到现在就说完了，接下来我们看看使用koa来启动一个app的时候，koa内部会发生什么呢？</p>\n<h2>启动server</h2>\n<p>我们使用koa来启动server的时候有两个步骤。第一步是init一个app对象，第二步是用app对象监听下端口号，一个server就启动好了。</p>\n<pre class=\"prettyprint language-javascript\"><code>&#x2F;&#x2F; 第一步 - 初始化app对象\nvar koa = require(&#x27;koa&#x27;);\nvar app = koa();\n\n&#x2F;&#x2F; 第二步 - 监听端口\napp.listen(1995);\n</code></pre><p>简单吧？</p>\n<p>不了解内部机制的同学，通常会认为server是在<code>koa()</code>这个时候启动的，<code>app.listen</code>只是监听下端口而已~</p>\n<p>事实上。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。并不是。</p>\n<p>有木有被刷新三观？？？</p>\n<p>我们看下源码片段</p>\n<pre class=\"prettyprint language-javascript\"><code>module.exports = Application;\n\nfunction Application() {\n  if (!(this instanceof Application)) return new Application;\n  this.env = process.env.NODE_ENV || &#x27;development&#x27;;\n  this.subdomainOffset = 2;\n  this.middleware = [];\n  this.proxy = false;\n  this.context = Object.create(context);\n  this.request = Object.create(request);\n  this.response = Object.create(response);\n}\n</code></pre><p>从源码中可以看到，执行<code>koa()</code>的时候初始化了一些很有用的东西，包括初始化一个空的中间件集合，基于Request，Response，Context为原型，生成实例等操作。</p>\n<p><strong>Request和Response的属性和方法委托到Context中也是在这一步进行的</strong></p>\n<p>并没有启动server</p>\n<p>我们看第二步，在看一段源码</p>\n<pre class=\"prettyprint language-javascript\"><code>app.listen = function(){\n  debug(&#x27;listen&#x27;);\n  var server = http.createServer(this.callback());\n  return server.listen.apply(server, arguments);\n};\n</code></pre><p>可以看到，在执行<code>app.listen(1995)</code>的时候，启动了一个server，并且监听端口。熟悉nodejs的同学知道http.createServer接收一个函数作为参数，每次服务器接收到请求都会执行这个函数，并传入两个参数（request和response，简称req和res），那么现在重点在<code>this.callback</code>这个方法上。</p>\n<p>我们一起看一下<code>this.callback</code>是何方神圣</p>\n<pre class=\"prettyprint language-javascript\"><code>app.callback = function(){\n  if (this.experimental) {\n    console.error(&#x27;Experimental ES7 Async Function support is deprecated. Please look into Koa v2 as the middleware signature has changed.&#x27;)\n  }\n  var fn = this.experimental\n    ? compose_es7(this.middleware)\n    : co.wrap(compose(this.middleware));\n  var self = this;\n\n  if (!this.listeners(&#x27;error&#x27;).length) this.on(&#x27;error&#x27;, this.onerror);\n\n  return function(req, res){\n    res.statusCode = 404;\n    var ctx = self.createContext(req, res);\n    onFinished(res, ctx.onerror);\n    fn.call(ctx).then(function () {\n      respond.call(ctx);\n    }).catch(ctx.onerror);\n  }\n};\n</code></pre><p><strong>这个方法其实可以分成两部分，一部分是执行函数的那一瞬间所执行的代码，另一部分是接收请求的时候所执行的代码。</strong></p>\n<p>而前一部分就是总体流程图中，启动server这个时间段，黄色椭圆形所执行的那一部分，<strong>初始化中间件！！！</strong></p>\n<h3>第一部分</h3>\n<p>先说第一部分，很明显，这环节是在<strong>初始化中间件</strong>，那为什么要初始化中间件呢？处理后的中间件与处理之前的中间件又有什么不同呢？？？？</p>\n<p>童鞋，，，不要着急，听我慢慢道来~~</p>\n<p>我们添加中间的时候使用<code>app.use</code>方法，其实这个方法只是把中间件push到一个数组，然后就没有然后了。。(⊙﹏⊙)</p>\n<p>很明显，所有中间件都在数组中，那么它们之间是没有联系的，如果没有联系，就不可能实现<code>流水线</code>这样的功能。。。。</p>\n<p>那么这些中间件处理之后会变成什么样的？？？？</p>\n<p>我们先看代码，上面的代码中用<code>this.experimental</code>这个属性做了一个判断。这个属性是什么鸟。</p>\n<p><code>this.experimental</code> 关于这个属性我并没有在官方文档上看到说明，但以我对koa的了解，这个方法是为了判断是否支持es7，默认是不支持的，如果想支持，需要在代码中明确指定<code>this.experimental = true</code>，开启这个属性之后，中间件可以传入async函数。</p>\n<p>我想说的是，无论是否开启ES7，原理都是相同的，只是因为语法特性的不同，需要不同的处理，核心思想不会因为不同的语言特性而改变，支持ES7显然处理起来更方便，因为默认不开启<code>this.experimental</code>，所以这里我们针对不开启的情况进行讨论~</p>\n<p>这样一来，第一部分的代码就简化成了这样</p>\n<pre class=\"prettyprint language-javascript\"><code>var fn = co.wrap(compose(this.middleware));\n</code></pre><p>虽然只剩下一行代码，但不要小瞧它哦~~</p>\n<p>我们先看<code>compose(this.middleware)</code>这部分，<code>compose</code>的全名叫<code>koa-compose</code>，他的作用是把一个个不相干的中间件串联在一起。。</p>\n<p>例如</p>\n<pre class=\"prettyprint language-javascript\"><code>&#x2F;&#x2F; 有3个中间件\nthis.middlewares = [function *m1() {}, function *m2() {}, function *m3() {}];\n\n&#x2F;&#x2F; 通过compose转换\nvar middleware = compose(this.middlewares);\n\n&#x2F;&#x2F; 转换后得到的middleware是这个样子的\nfunction *() {\n  yield *m1(m2(m3(noop())))\n}\n</code></pre><p>有木有很神奇的感觉？？更神奇的是，generator函数的特性是，第一次执行并不会执行函数里的代码，而是生成一个generator对象，这个对象有next，throw等方法。</p>\n<p><strong>这就造成了一个现象，每个中间件都会有一个参数，这个参数就是下一个中间件执行后，生成出来的generator对象</strong>，没错，这就是大名鼎鼎的 <strong>next</strong></p>\n<p>那<code>compose</code>是如何实现这样的功能的呢？？我们看一下代码</p>\n<pre class=\"prettyprint language-javascript\"><code>&#x2F;**\n * Expose compositor.\n *&#x2F;\n\nmodule.exports = compose;\n\n&#x2F;**\n * Compose &#96;middleware&#96; returning\n * a fully valid middleware comprised\n * of all those which are passed.\n *\n * @param {Array} middleware\n * @return {Function}\n * @api public\n *&#x2F;\n\nfunction compose(middleware){\n  return function *(next){\n    if (!next) next = noop();\n\n    var i = middleware.length;\n\n    while (i--) {\n      next = middleware[i].call(this, next);\n    }\n\n    return yield *next;\n  }\n}\n\n&#x2F;**\n * Noop.\n *\n * @api private\n *&#x2F;\n\nfunction *noop(){}\n</code></pre><p>这是这个模块的所有代码，很简单，逻辑是这样的</p>\n<p>先把中间件从后往前依次执行，并把每一个中间件执行后得到的generator对象赋值给变量next，当下一次执行中间件的时候（也就是执行前一个中间件的时候），把next传给第一个参数。这样就保证前一个中间件的参数是下一个中间件生成的generator对象，第一次执行的时候next为<code>noop</code>，<code>noop</code>是空的generator函数。</p>\n<p>koa的中间件必须为generator函数（就是带星号的函数），否则无法顺利的执行中间件逻辑</p>\n<p>最后，有一个非常巧妙的地方，就是最后一行<code>return yield *next;</code></p>\n<p>这行代码可以实现把<code>compose</code>执行后return的函数变成第一个中间件，也就是说，执行<code>compose</code>之后会得到一个函数，执行这个函数就与执行第一个中间件的效果是一模一样的，这主要依赖了generator函数的yield *语句的特性。</p>\n<p>现在中间件的状态就已经从<code>不可用</code>变成<code>可用</code>了。不可用的中间件是一个数组，可用的中间件是一个<strong>generator函数</strong>。</p>\n<p>我们接着说刚才没说完的</p>\n<pre class=\"prettyprint language-javascript\"><code>var fn = co.wrap(compose(this.middleware));\n</code></pre><p>上面这段代码现在就可以理解成下面这样</p>\n<pre class=\"prettyprint language-javascript\"><code>var fn = co.wrap(function *() {yield *m1(m2(m3(noop())))});\n</code></pre><p>里面的函数刚刚已经说过是可用状态的中间件，那么<code>co.wrap</code>是干什么用的呢？？</p>\n<p>co是TJ大神基于Generator开发的一款流程控制模块，白话文就是：就是把异步变成同步的模块。。。（感觉逼格瞬间拉低了。。。）</p>\n<p>看下源码</p>\n<pre class=\"prettyprint language-javascript\"><code>co.wrap = function (fn) {\n  createPromise.__generatorFunction__ = fn;\n  return createPromise;\n  function createPromise() {\n    return co.call(this, fn.apply(this, arguments));\n  }\n};\n</code></pre><p>从源码中可以看到，它接收一个参数，这个参数就是可用状态下的中间件，返回一个函数createPromise，当执行createPromise这个函数的时候，调用co并传入一个参数，这个参数是中间件函数执行后生成的Generator对象。</p>\n<p><strong>这意味着，返回的这个函数是触发执行中间件逻辑的关键，一旦这个函数被执行，那么就会开始执行中间件逻辑</strong></p>\n<pre class=\"prettyprint language-javascript\"><code>app.callback = function(){\n  if (this.experimental) {\n    console.error(&#x27;Experimental ES7 Async Function support is deprecated. Please look into Koa v2 as the middleware signature has changed.&#x27;)\n  }\n  var fn = this.experimental\n    ? compose_es7(this.middleware)\n    : co.wrap(compose(this.middleware));\n  var self = this;\n\n  if (!this.listeners(&#x27;error&#x27;).length) this.on(&#x27;error&#x27;, this.onerror);\n\n  return function(req, res){\n    res.statusCode = 404;\n    var ctx = self.createContext(req, res);\n    onFinished(res, ctx.onerror);\n    fn.call(ctx).then(function () {\n      respond.call(ctx);\n    }).catch(ctx.onerror);\n  }\n};\n</code></pre><p>从源码中，可以看到这个函数赋值给fn，fn是在下面那个函数中执行的，下面那个函数是接下来要说的内容~</p>\n<p>到现在，我们的koa已经处于一种待机状态，所有准备都以准备好（中间件和context），万事俱备，只欠东风。。。。。。</p>\n<p>东风就是request请求~~</p>\n<h2>接收请求</h2>\n<p>前面说了启动前的一些准备工作和启动时的初始化工作，现在最后一步就是接收请求的时候，koa要做的事情了，这部分也是koa中难度最大的一部分。不过认真阅读下去会有收获的。。</p>\n<p>上面我们说<code>this.callback</code>这个方法有两个部分，第一个部分是初始化中间件，而另一部分就是接收请求时执行的函数啦。</p>\n<p>简单回顾下</p>\n<pre class=\"prettyprint language-javascript\"><code>&#x2F;&#x2F; 创建server并监听端口\napp.listen = function(){\n  debug(&#x27;listen&#x27;);\n  var server = http.createServer(this.callback());\n  return server.listen.apply(server, arguments);\n};\n\n&#x2F;&#x2F; 这个方法返回的函数会被传递到http.createServer中，http.createServer这个方法的作用是每当服务器接收到请求的时候，都会执行第一个参数，并且会传递request和response\napp.callback = function(){\n  if (this.experimental) {\n    console.error(&#x27;Experimental ES7 Async Function support is deprecated. Please look into Koa v2 as the middleware signature has changed.&#x27;)\n  }\n  var fn = this.experimental\n    ? compose_es7(this.middleware)\n    : co.wrap(compose(this.middleware));\n  var self = this;\n\n  if (!this.listeners(&#x27;error&#x27;).length) this.on(&#x27;error&#x27;, this.onerror);\n\n  return function(req, res){\n    res.statusCode = 404;\n    var ctx = self.createContext(req, res);\n    onFinished(res, ctx.onerror);\n    fn.call(ctx).then(function () {\n      respond.call(ctx);\n    }).catch(ctx.onerror);\n  }\n};\n</code></pre><p>所以第二部分的重点就是下面段代码啦~</p>\n<pre class=\"prettyprint language-javascript\"><code>return function(req, res){\n  res.statusCode = 404;\n  var ctx = self.createContext(req, res);\n  onFinished(res, ctx.onerror);\n  fn.call(ctx).then(function () {\n    respond.call(ctx);\n  }).catch(ctx.onerror);\n}\n</code></pre><p>我们先看这段代码</p>\n<pre class=\"prettyprint language-javascript\"><code>var ctx = self.createContext(req, res);\n</code></pre><p>不知道各位童鞋还记不记得文章一开始的时候那个总体流程图下面的那个类似于八卦一样的东西？？？</p>\n<p>这行代码就是创建一个最终可用版的context。</p>\n<img src=\"http://berwin.github.io/ppts/koa/img/context.png\" width=\"100%\">\n<p>从上图中，可以看到分别有五个箭头指向ctx，表示ctx上包含5个属性，分别是request，response，req，res，app。request和response也分别有5个箭头指向它们，所以也是同样的逻辑。</p>\n<p>这里需要说明下</p>\n<ul>\n<li>request - request继承于Request静态类，包含操作request的一些常用方法</li>\n<li>response - response继承于Response静态类，包含操作response的一些常用方法</li>\n<li>req - nodejs原生的request对象</li>\n<li>res - nodejs原生的response对象</li>\n<li>app - koa的原型对象</li>\n</ul>\n<p>不多说，咱们观摩下代码</p>\n<pre class=\"prettyprint language-javascript\"><code>app.createContext = function(req, res){\n  \n  &#x2F;&#x2F; 继承\n  var context = Object.create(this.context);\n  var request = context.request = Object.create(this.request);\n  var response = context.response = Object.create(this.response);\n  \n  &#x2F;&#x2F; 往context，request，response身上挂载属性\n  context.app = request.app = response.app = this;\n  context.req = request.req = response.req = req;\n  context.res = request.res = response.res = res;\n  request.ctx = response.ctx = context;\n  request.response = response;\n  response.request = request;\n  context.onerror = context.onerror.bind(context);\n  context.originalUrl = request.originalUrl = req.url;\n  context.cookies = new Cookies(req, res, {\n    keys: this.keys,\n    secure: request.secure\n  });\n  context.accept = request.accept = accepts(req);\n  context.state = {};\n  \n  &#x2F;&#x2F; 最后返回完整版context\n  return context;\n};\n</code></pre><p>讲到这里其实我可以很明确的告诉大家，，，koa中的<code>this</code>其实就是<code>app.createContext</code>方法返回的完整版<code>context</code></p>\n<p>又由于这段代码的执行时间是接受请求的时候，所以表明<strong>每一次接受到请求，都会为该请求生成一个新的上下文</strong></p>\n<p>上下文到这里我们就说完啦。我们接着往下说，看下一行代码</p>\n<pre class=\"prettyprint language-javascript\"><code>onFinished(res, ctx.onerror);\n</code></pre><p>这行代码其实很简单，就是监听response，如果response有错误，会执行<code>ctx.onerror</code>中的逻辑，设置response类型，状态码和错误信息等。</p>\n<p>源码如下：</p>\n<pre class=\"prettyprint language-javascript\"><code>onerror: function(err){\n  &#x2F;&#x2F; don&#x27;t do anything if there is no error.\n  &#x2F;&#x2F; this allows you to pass &#96;this.onerror&#96;\n  &#x2F;&#x2F; to node-style callbacks.\n  if (null == err) return;\n\n  if (!(err instanceof Error)) err = new Error(&#x27;non-error thrown: &#x27; + err);\n\n  &#x2F;&#x2F; delegate\n  this.app.emit(&#x27;error&#x27;, err, this);\n\n  &#x2F;&#x2F; nothing we can do here other\n  &#x2F;&#x2F; than delegate to the app-level\n  &#x2F;&#x2F; handler and log.\n  if (this.headerSent || !this.writable) {\n    err.headerSent = true;\n    return;\n  }\n\n  &#x2F;&#x2F; unset all headers\n  this.res._headers = {};\n\n  &#x2F;&#x2F; force text&#x2F;plain\n  this.type = &#x27;text&#x27;;\n\n  &#x2F;&#x2F; ENOENT support\n  if (&#x27;ENOENT&#x27; == err.code) err.status = 404;\n\n  &#x2F;&#x2F; default to 500\n  if (&#x27;number&#x27; != typeof err.status || !statuses[err.status]) err.status = 500;\n\n  &#x2F;&#x2F; respond\n  var code = statuses[err.status];\n  var msg = err.expose ? err.message : code;\n  this.status = err.status;\n  this.length = Buffer.byteLength(msg);\n  this.res.end(msg);\n}\n</code></pre><p>我们接着说，还有最后一个知识点，也是本章最复杂的知识点，关于中间件的执行流程，这里会说明为什么koa的中间件可以回逆。</p>\n<p>我们先看代码</p>\n<pre class=\"prettyprint language-javascript\"><code>fn.call(ctx).then(function () {\n  respond.call(ctx);\n}).catch(ctx.onerror);\n</code></pre><ul>\n<li>fn - 我们上面讲的<code>co.wrap</code>返回的那个函数</li>\n<li>ctx - app.createContext执行后返回的完整版context对象</li>\n</ul>\n<p>总体上来说，执行<code>fn.call(ctx)</code>会返回promise，koa会监听执行的成功和失败，成功则执行<code>respond.call(ctx);</code>，失败则执行<code>ctx.onerror</code>，失败的回调函数刚刚已经讲过。这里先说说<code>respond.call(ctx);</code>。</p>\n<p>我们在写koa的时候，会发现所有的response操作都是\n<code>this.body = xxx;</code> <code>this.status = xxxx;</code>这样的语法，但如果对原生nodejs有了解的童鞋知道，nodejs的response只有一个api那就是<code>res.end();</code>，而设置status状态码什么的都有不同的api，那么koa是如何做到通过<code>this.xxx = xxx</code>来设置response的呢？</p>\n<p>先看一张图，，我盗的图</p>\n<img src=\"http://berwin.github.io/ppts/koa/img/process_koa.png\" width=\"100%\">\n<p>从图中看到，request请求是以respond结束的。</p>\n<p>是滴，所有的request请求都是以respond这个函数结束的，这个函数会读取this.body中的值根据不同的类型来决定以什么类型响应请求</p>\n<p>我们来欣赏一下源码</p>\n<pre class=\"prettyprint language-javascript\"><code>function respond() {\n  &#x2F;&#x2F; allow bypassing koa\n  if (false === this.respond) return;\n\n  var res = this.res;\n  if (res.headersSent || !this.writable) return;\n\n  var body = this.body;\n  var code = this.status;\n\n  &#x2F;&#x2F; ignore body\n  if (statuses.empty[code]) {\n    &#x2F;&#x2F; strip headers\n    this.body = null;\n    return res.end();\n  }\n\n  if (&#x27;HEAD&#x27; == this.method) {\n    if (isJSON(body)) this.length = Buffer.byteLength(JSON.stringify(body));\n    return res.end();\n  }\n\n  &#x2F;&#x2F; status body\n  if (null == body) {\n    this.type = &#x27;text&#x27;;\n    body = this.message || String(code);\n    this.length = Buffer.byteLength(body);\n    return res.end(body);\n  }\n\n  &#x2F;&#x2F; responses\n  if (Buffer.isBuffer(body)) return res.end(body);\n  if (&#x27;string&#x27; == typeof body) return res.end(body);\n  if (body instanceof Stream) return body.pipe(res);\n\n  &#x2F;&#x2F; body: json\n  body = JSON.stringify(body);\n  this.length = Buffer.byteLength(body);\n  res.end(body);\n}\n</code></pre><p>仔细阅读的童鞋会发现，咦，，，，为毛没有设置status和header等信息的代码逻辑？这不科学啊。我分明记得状态码是<code>rs.statusCode = 400</code>这样设置的，为啥代码中没有？？</p>\n<p>这就要从最开始的上下文说起了。为什么Response静态类中添加req和res属性？就是因为添加了req和res之后，response和request类就可以直接操作req和res啦。。我们看一段源码就明白了</p>\n<pre class=\"prettyprint language-javascript\"><code>set status(code) {\n  assert(&#x27;number&#x27; == typeof code, &#x27;status code must be a number&#x27;);\n  assert(statuses[code], &#x27;invalid status code: &#x27; + code);\n  this._explicitStatus = true;\n  this.res.statusCode = code;\n  this.res.statusMessage = statuses[code];\n  if (this.body &amp;&amp; statuses.empty[code]) this.body = null;\n},\n</code></pre><p>主要是<code>this.res.statusCode = code;</code> <code>this.res.statusMessage = statuses[code];</code>这两句，<code>statusCode</code>和<code>statusMessage</code>都是nodejs原生api。有兴趣可以自行查看~</p>\n<p>接下来我们开始说说koa的中间件为什么可以回逆，为什么koa的中间件必须使用generator，yield next又是个什么鬼？</p>\n<p>我们看这段代码</p>\n<pre class=\"prettyprint language-javascript\"><code>fn.call(ctx)\n</code></pre><p>fn刚刚上面说过，就是<code>co.wrap</code>返回的那个函数，上面也说过，一旦这个函数执行，就会执行中间件逻辑，并且通过<code>.call</code>把<code>ctx</code>设为上下文，也就是this。</p>\n<p>那中间件逻辑是什么样的呢。我们先看一下源码：</p>\n<pre class=\"prettyprint language-javascript\"><code>co.wrap = function (fn) {\n  createPromise.__generatorFunction__ = fn;\n  return createPromise;\n  function createPromise() {\n    return co.call(this, fn.apply(this, arguments));\n  }\n};\n</code></pre><p>先回顾下，createPromise就是fn，每当执行createPromise的时候，都会执行co，中间件是基于co实现的、所以我们接下来要说的是co的实现逻辑。而执行co所传递的那个参数，我们给它起个名，就叫<code>中间件函数</code>吧，中间件函数也是一个generator函数，因为在执行co的时候执行了这个中间件函数，所以实际上真正传递给co的参数是一个generator对象，为了方便理解，我们先起个名叫<code>中间件对象吧</code></p>\n<p>那我们看co的源码：</p>\n<pre class=\"prettyprint language-javascript\"><code>function co(gen) {\n  var ctx = this;\n  var args = slice.call(arguments, 1)\n\n  &#x2F;&#x2F; we wrap everything in a promise to avoid promise chaining,\n  &#x2F;&#x2F; which leads to memory leak errors.\n  &#x2F;&#x2F; see https:&#x2F;&#x2F;github.com&#x2F;tj&#x2F;co&#x2F;issues&#x2F;180\n  return new Promise(function(resolve, reject) {\n    if (typeof gen === &#x27;function&#x27;) gen = gen.apply(ctx, args);\n    if (!gen || typeof gen.next !== &#x27;function&#x27;) return resolve(gen);\n\n    onFulfilled();\n\n    &#x2F;**\n     * @param {Mixed} res\n     * @return {Promise}\n     * @api private\n     *&#x2F;\n\n    function onFulfilled(res) {\n      var ret;\n      try {\n        ret = gen.next(res);\n      } catch (e) {\n        return reject(e);\n      }\n      next(ret);\n    }\n\n    &#x2F;**\n     * @param {Error} err\n     * @return {Promise}\n     * @api private\n     *&#x2F;\n\n    function onRejected(err) {\n      var ret;\n      try {\n        ret = gen.throw(err);\n      } catch (e) {\n        return reject(e);\n      }\n      next(ret);\n    }\n\n    &#x2F;**\n     * Get the next value in the generator,\n     * return a promise.\n     *\n     * @param {Object} ret\n     * @return {Promise}\n     * @api private\n     *&#x2F;\n\n    function next(ret) {\n      if (ret.done) return resolve(ret.value);\n      var value = toPromise.call(ctx, ret.value);\n      if (value &amp;&amp; isPromise(value)) return value.then(onFulfilled, onRejected);\n      return onRejected(new TypeError(&#x27;You may only yield a function, promise, generator, array, or object, &#x27;\n        + &#x27;but the following object was passed: &quot;&#x27; + String(ret.value) + &#x27;&quot;&#x27;));\n    }\n  });\n}\n</code></pre><p>可以看到，代码并不是很多。</p>\n<p>首先执行co会返回一个promise，koa会对这个promise的成功和失败都准备了不同的处理，上面已经说过。</p>\n<p>我们在看这段代码</p>\n<pre class=\"prettyprint language-javascript\"><code>function onFulfilled(res) {\n  var ret;\n  try {\n    ret = gen.next(res);\n  } catch (e) {\n    return reject(e);\n  }\n  next(ret);\n}\n</code></pre><p>这个函数最重要的作用是运行<code>gen.next</code>来执行中间件中的业务逻辑。</p>\n<p>通常在开发中间件的时候会这样写</p>\n<pre class=\"prettyprint language-javascript\"><code>yield next;\n</code></pre><p>所以ret中包含下一个<code>中间件对象</code>（还记得上面我们初始化中间件的时候中间件的参数是什么了吗？？）</p>\n<p>然后把下一个中间件对象传到了<code>next(ret)</code>这个函数里，next函数是干什么的？我们看看</p>\n<pre class=\"prettyprint language-javascript\"><code>function next(ret) {\n  if (ret.done) return resolve(ret.value);\n  var value = toPromise.call(ctx, ret.value);\n  if (value &amp;&amp; isPromise(value)) return value.then(onFulfilled, onRejected);\n  return onRejected(new TypeError(&#x27;You may only yield a function, promise, generator, array, or object, &#x27;\n    + &#x27;but the following object was passed: &quot;&#x27; + String(ret.value) + &#x27;&quot;&#x27;));\n}\n</code></pre><p>可以看到，逻辑是这样的</p>\n<p>如果中间件已经结束（没有yield了），那么调用promise的resolve。</p>\n<p>否则的话把ret.value（就是下一个中间件对象），用co在包一层<code>toPromise.call(ctx, ret.value);</code></p>\n<pre class=\"prettyprint language-javascript\"><code>if (isGeneratorFunction(obj) || isGenerator(obj)) return co.call(this, obj);\n</code></pre><p>上面是toPromise中的一段代码</p>\n<p>既然是用co又执行了一遍，那么co是返回promise的。所以返回的这个value就分别被监听了成功和失败的不同处理。</p>\n<pre class=\"prettyprint language-javascript\"><code>value.then(onFulfilled, onRejected);\n</code></pre><p>所以我们可以看到，如果第二个中间件里依然有<code>yield next</code>这样的语句，那么第三个中间件依然会被co包裹一层并运行.next方法，依次列推，这是一个递归的操作</p>\n<p>所以我们可以肯定的是，每一个中间件都被promise包裹着，直到有一天中间件中的逻辑运行完成了，那么会调用promise的resolve来告诉程序这个中间件执行完了。</p>\n<p>那么中间件执行完了之后，会触发<code>onFulfilled</code>，这个函数会执行.next方法。</p>\n<p>所以有一个非常重要的一点需要注意，<code>onFulfilled</code>这个函数非常重要，重要在哪里？？？重要在它执行的时间上。</p>\n<p><strong><code>onFulfilled</code>这个函数只在两种情况下被调用，一种是调用co的时候执行，还有一种是当前promise中的所有逻辑都执行完毕后执行</strong></p>\n<p>其实就这一句话就能说明koa的中间件为什么会回逆。</p>\n<p>回逆其实是有一个去和一个回的操作</p>\n<img src=\"http://berwin.github.io/ppts/koa/img/koa-middleware3.png\" width=\"250px\">\n<p>请求的时候经过一次中间件，响应的时候在经过一次中间件。</p>\n<p>而onFulfilled的两种被调用的情况正好和这个回逆的过程对应上。</p>\n<p>前方高能预警！！！</p>\n<p><strong>比如有3个中间件，当系统接收到请求的时候，会执行co，co会立刻执行onFulfilled来调用.next往下执行，将得到的返回结果（第二个中间件的generator对象，上面我们分析过）传到co中在执行一遍。以此类推，一直运行到最后一个yield，这个时候系统会等待中间件的执行结束，一旦最后一个中间件执行完毕，会立刻调用promise的resolve方法表示结束。（这个时候onFulfilled函数的第二个执行时机到了，这样就会出现一个现象，一个generator对象的yield只能被next一次，下次执行.next的时候从上一次停顿的yield处继续执行，所以现在当有一个中间件执行完毕后，在执行.next就会在前一个中间件的yield处继续执行）当最后一个中间件执行完毕后，触发promise的resolve，而别忘了，第二个中间件可是用then监听了成功和失败的不同处理方法，一旦第三个中间件触发成功，第二个中间件会立刻调用onFulfilled来执行.next，继续从第二个中间件上一次yield停顿处开始执行下面的代码，而第二个中间件的逻辑执行完毕后，同样会执行resolve表示成功，而这个时候第一个中间件正好也通过.then方法监听了第二个中间件的promise，也会立刻调用onFulfilled函数来执行.next方法，这样就会继续从第一个中间件上一次yield的停顿处继续执行下面的逻辑，以此类推。</strong></p>\n<p>这样就实现了中间件的回逆，通过递归从外到里执行一遍中间件，然后在通过promise+generator从里往外跳。</p>\n<p>所以如果我们在一个中间件中写好多yield，就可以看出关键所在，先通过递归从外往里（从第一个中间件运行到最后一个中间件）每次遇到yield next就会进入到下一个中间件执行，当运行到最后发现没有yield的时候，会跳回上一个中间件继续执行yield后面的，结果发现又有一个yield next，它会再次进入到下一个中间件，进入到下一个中间件后发现什么都没有，因为yield的特性（一个generator对象的yield只能被next一次，下次执行.next的时候从上一次停顿的yield处继续执行），所以便又一次跳入上一个中间件来执行。以此类推。</p>\n<p>我们试一下：</p>\n<pre class=\"prettyprint language-javascript\"><code>var koa = require(&#x27;koa&#x27;);\nvar app = koa();\n\napp.use(function* f1(next) {\n  console.log(&#x27;f1: pre next&#x27;);\n  yield next;\n  console.log(&#x27;f1: post next&#x27;);\n  yield next;\n  console.log(&#x27;f1: fuck&#x27;);\n});\n\napp.use(function* f2(next) {\n  console.log(&#x27;  f2: pre next&#x27;);\n  yield next;\n  console.log(&#x27;  f2: post next&#x27;);\n  yield next;\n  console.log(&#x27;  f2: fuck&#x27;);\n});\n\napp.use(function* f3(next) {\n  console.log(&#x27;  f3: pre next&#x27;);\n  yield next;\n  console.log(&#x27;  f3: post next&#x27;);\n  yield next;\n  console.log(&#x27;  f3: fuck&#x27;);\n});\n\napp.use(function* (next) {\n  console.log(&#x27;hello world&#x27;)\n  this.body = &#x27;hello world&#x27;;\n});\n\n\napp.listen(3000);\n</code></pre><p>上面的代码打印的log是下面这样的</p>\n<pre class=\"prettyprint language-javascript\"><code>f1: pre next\n  f2: pre next\n  f3: pre next\nhello world\n  f3: post next\n  f3: fuck\n  f2: post next\n  f2: fuck\nf1: post next\nf1: fuck\n</code></pre><p>如果非要画一个图的话，我脑海中大概长这样</p>\n<img src=\"http://berwin.github.io/ppts/koa/img/co.png\" width=\"100%\">\n<p>其实刚刚那么一通复杂的逻辑下来，好多同学都会懵逼，那么我用白话文来说一下中间件的逻辑，大概是这样的</p>\n<p><strong>第一个中间件代码执行一半停在这了，触发了第二个中间件的执行，第二个中间件执行了一半停在这了，触发了第三个中间件的执行，然后，，，，，，第一个中间件等第二个中间件，第二个中间件等第三个中间件，，，，，，第三个中间件全部执行完毕，第二个中间件继续执行后续代码，第二个中间件代码全部执行完毕，执行第一个中间件后续代码，然后结束</strong></p>\n<p>用一张图表示大概是这样的。</p>\n<p><img src=\"https://cloud.githubusercontent.com/assets/3739368/14908102/e58c340a-0e04-11e6-93ba-ac04e342ae7f.png\" alt=\"middleware\"></p>\n<p>为了方便理解，伪代码大概是下面这样</p>\n<pre class=\"prettyprint language-javascript\"><code>new Promise(function(resolve, reject) {\n  &#x2F;&#x2F; 我是中间件1\n  yield new Promise(function(resolve, reject) {\n    &#x2F;&#x2F; 我是中间件2\n    yield new Promise(function(resolve, reject) {\n      &#x2F;&#x2F; 我是中间件3\n      yield new Promise(function(resolve, reject) {\n        &#x2F;&#x2F; 我是body\n      });\n      &#x2F;&#x2F; 我是中间件3\n    });\n    &#x2F;&#x2F; 我是中间件2\n  });\n  &#x2F;&#x2F; 我是中间件1\n});\n</code></pre><p>这就是最核心的思想！！！</p>\n<h4>总结</h4>\n<p>简单总结一下，其实也很简单，只是第一次接触的同学可能暂时没有理解透彻。</p>\n<p>其实就是通过generator来暂停函数的执行逻辑来实现等待中间件的效果，通过监听promise来触发继续执行函数逻辑，所谓的回逆也不过就是同步执行了下一个中间件罢了。</p>\n<p>比如有几个中间件，mw1,mw2,mw3,mwn…</p>\n<p>站在mw1的角度上看，它是不需要关系mw2里面有没有mw3，它只需要关心mw2何时执行完毕即可，当mw2执行完毕mw1继续执行yield之后的代码逻辑。其实很简单，callback也是这个原理，当mw2执行完毕执行下callback，mw1是不需要关心mw2里面究竟是怎样运行的，只要知道mw2执行完会执行回调就行了。mw2也是同样的道理不需要关心mw3。</p>\n<p>到这里，关于koa我们就已经差不多都说完了。当然还有一些细节没有说，比如koa中的错误处理，但其实都是小问题啦，关于generator的错误处理部分弄明白了，自然就明白koa的错误处理是怎样的。这里就不在针对这些讲述了，一次写这么多确实有点累，或许后期会补充进来吧。。</p>\n<h2>两个重要技术点</h2>\n<p>最后，如果认真阅读下来的同学能感觉出来，koa中有两个最重要的地方，无论是使用上，还是思想上，这两个点都非常重要，koa也只有这两个概念</p>\n<ul>\n<li>Middleware - 中间件</li>\n<li>Context - 上下文</li>\n</ul>\n<p>最后说一些自己对koa的感觉，真他妈的是赏心悦目啊，真他妈的是优雅啊！！！每一行代码都浓缩了很多层含义，通过最少的代码实现最复杂的功能，对于我这种追求代码的极致优雅的人，看完koa之后，真的是感触良多，泪流满面啊。。。。</p>\n<p>ppt：<a href=\"http://berwin.github.io/ppts/koa/\">http://berwin.github.io/ppts/koa/</a></p>\n<p>转载请注明出处</p>\n<p><img src=\"https://cloud.githubusercontent.com/assets/3739368/17135002/0c2d3eb0-5360-11e6-8c7d-5af47343303d.jpg\" width=\"320px\"><img src=\"https://cloud.githubusercontent.com/assets/3739368/17135005/0e5e525a-5360-11e6-9233-a0cdfd1caead.jpg\" width=\"320px\"></p>\n</div>","title":"深入浅出 Koa","last_reply_at":"2016-08-02T10:58:44.630Z","good":true,"top":false,"reply_count":29,"visit_count":6348,"create_at":"2016-03-14T09:47:21.178Z","author":{"loginname":"berwin","avatar_url":"https://avatars.githubusercontent.com/u/3739368?v=3&s=120"}}]}